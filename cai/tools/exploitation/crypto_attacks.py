"""
Cryptographic Attack Toolkit for CAI

This module provides comprehensive cryptographic attack tools including
hash cracking, cipher analysis, certificate attacks, and cryptographic weakness exploitation.
"""

import os
import re
import time
import json
import base64
import hashlib
import binascii
import itertools
import string
from typing import Dict, List, Tuple, Optional, Any
from cai.tools.common import run_command


def automated_crypto_assessment(target_data: str = None, ctf=None, **kwargs) -> str:
    """
    Perform comprehensive cryptographic security assessment
    
    Args:
        target_data: Data to analyze (hash, ciphertext, certificate, etc.)
        
    Returns:
        str: Detailed crypto assessment results
    """
    results = []
    results.append("=== Cryptographic Security Assessment ===")
    results.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    results.append("")

    try:
        # 1. Hash Analysis
        results.append("=== Hash Analysis ===")
        hash_analysis = analyze_hashes(target_data, ctf=ctf)
        results.append(hash_analysis)
        results.append("")

        # 2. Cipher Analysis
        results.append("=== Cipher Analysis ===")
        cipher_analysis = analyze_ciphers(target_data, ctf=ctf)
        results.append(cipher_analysis)
        results.append("")

        # 3. Certificate Analysis
        results.append("=== Certificate Analysis ===")
        cert_analysis = analyze_certificates(ctf=ctf)
        results.append(cert_analysis)
        results.append("")

        # 4. Cryptographic Weakness Detection
        results.append("=== Cryptographic Weakness Detection ===")
        weakness_analysis = detect_crypto_weaknesses(target_data, ctf=ctf)
        results.append(weakness_analysis)
        results.append("")

        # 5. Hash Cracking Assessment
        results.append("=== Hash Cracking Assessment ===")
        cracking_assessment = assess_hash_cracking_opportunities(ctf=ctf)
        results.append(cracking_assessment)
        results.append("")

        return "\n".join(results)

    except Exception as e:
        return f"Error during crypto assessment: {str(e)}"


def analyze_hashes(target_data: str = None, ctf=None, **kwargs) -> str:
    """Analyze and identify hash types and potential weaknesses"""
    results = []

    try:
        results.append("Analyzing hash types and formats...")

        # Common hash patterns and their characteristics
        hash_patterns = {
            'MD5': (r'^[a-f0-9]{32}$', 32, 'md5sum'),
            'SHA1': (r'^[a-f0-9]{40}$', 40, 'sha1sum'),
            'SHA256': (r'^[a-f0-9]{64}$', 64, 'sha256sum'),
            'SHA512': (r'^[a-f0-9]{128}$', 128, 'sha512sum'),
            'NTLM': (r'^[a-f0-9]{32}$', 32, 'ntlm'),
            'MySQL': (r'^\*[A-F0-9]{40}$', 41, 'mysql'),
            'bcrypt': (r'^\$2[ayb]\$.{56}$', 60, 'bcrypt'),
            'SHA-512 Crypt': (r'^\$6\$.*', None, 'sha512crypt'),
            'DES Crypt': (r'^[a-zA-Z0-9\./]{13}$', 13, 'descrypt')
        }

        if target_data:
            results.append(f"Analyzing target data: {target_data[:50]}...")

            # Try to identify hash type
            identified_hashes = []
            for hash_type, (pattern, length, hashcat_mode) in hash_patterns.items():
                if re.match(pattern, target_data.strip(), re.IGNORECASE):
                    identified_hashes.append((hash_type, hashcat_mode))

            if identified_hashes:
                results.append("🔍 Possible hash types:")
                for hash_type, mode in identified_hashes:
                    results.append(f"  - {hash_type} (hashcat mode: {mode})")

                # Check for weak hash algorithms
                weak_hashes = ['MD5', 'SHA1', 'DES Crypt', 'NTLM']
                for hash_type, _ in identified_hashes:
                    if hash_type in weak_hashes:
                        results.append(f"🔥 WEAK HASH DETECTED: {hash_type}")
            else:
                results.append("No standard hash patterns identified")

        # Search for hashes in common locations
        results.append(f"\n=== Hash Discovery ===")
        hash_locations = [
            "/etc/passwd",
            "/etc/shadow",
            "/var/log/auth.log",
            "C:\\Windows\\System32\\config\\SAM",
            "C:\\Windows\\NTDS\\NTDS.dit"
        ]

        for location in hash_locations:
            hash_search = run_command(f"cat {location} 2>/dev/null | head -5", ctf=ctf)
            if hash_search.strip() and "No such file" not in hash_search:
                results.append(f"🔑 Hash file found: {location}")
                # Look for password hashes
                hash_lines = [line for line in hash_search.split('\n') if ':' in line and len(line) > 20]
                if hash_lines:
                    results.append(f"  Sample entries: {len(hash_lines)} found")

        # Check for application-specific hashes
        results.append(f"\n=== Application Hash Analysis ===")

        # WordPress hashes
        wp_config = run_command("find / -name 'wp-config.php' 2>/dev/null | head -3", ctf=ctf)
        if wp_config.strip():
            results.append("🌐 WordPress installation found - check for password hashes")

        # Database hashes
        db_files = run_command("find / -name '*.sql' -o -name '*.db' 2>/dev/null | head -5", ctf=ctf)
        if db_files.strip():
            results.append(f"💾 Database files found:\n{db_files}")

    except Exception as e:
        results.append(f"Error analyzing hashes: {str(e)}")

    return "\n".join(results)


def analyze_ciphers(target_data: str = None, ctf=None, **kwargs) -> str:
    """Analyze ciphers and encrypted data"""
    results = []

    try:
        results.append("Analyzing ciphers and encrypted data...")

        if target_data:
            results.append(f"Analyzing data: {target_data[:100]}...")

            # Check for Base64 encoding
            if re.match(r'^[A-Za-z0-9+/]*={0,2}$', target_data.strip()):
                results.append("🔍 Possible Base64 encoding detected")
                try:
                    decoded = base64.b64decode(target_data)
                    results.append(f"Base64 decoded: {decoded[:50]}...")
                except:
                    results.append("Base64 decoding failed")

            # Check for hex encoding
            if re.match(r'^[a-fA-F0-9]+$', target_data.strip()) and len(target_data) % 2 == 0:
                results.append("🔍 Possible hex encoding detected")
                try:
                    decoded = binascii.unhexlify(target_data)
                    results.append(f"Hex decoded: {decoded[:50]}...")
                except:
                    results.append("Hex decoding failed")

            # Frequency analysis for cipher detection
            results.append(f"\n=== Frequency Analysis ===")
            char_freq = {}
            for char in target_data.lower():
                if char.isalpha():
                    char_freq[char] = char_freq.get(char, 0) + 1

            if char_freq:
                sorted_freq = sorted(char_freq.items(), key=lambda x: x[1], reverse=True)
                results.append(f"Most frequent characters: {sorted_freq[:5]}")

                # Check for Caesar cipher indicators
                if len(set(target_data.lower()) & set(string.ascii_lowercase)) > 10:
                    results.append("🔍 Possible substitution cipher (Caesar, Vigenère, etc.)")

        # Common cipher patterns
        cipher_patterns = {
            'Caesar Cipher': 'Simple letter substitution',
            'Vigenère Cipher': 'Polyalphabetic substitution',
            'ROT13': 'Caesar cipher with shift of 13',
            'Atbash': 'Hebrew alphabet reversal cipher',
            'Playfair': '5x5 grid substitution cipher',
            'Rail Fence': 'Transposition cipher'
        }

        results.append(f"\n=== Common Cipher Types ===")
        for cipher, description in cipher_patterns.items():
            results.append(f"- {cipher}: {description}")

        # Try common cipher attacks
        if target_data:
            results.append(f"\n=== Cipher Attack Attempts ===")

            # ROT13 attempt
            rot13_result = ''.join([chr((ord(c) - ord('a') + 13) % 26 + ord('a')) if c.islower()
                                    else chr((ord(c) - ord('A') + 13) % 26 + ord('A')) if c.isupper()
            else c for c in target_data])
            results.append(f"ROT13: {rot13_result[:50]}...")

            # Caesar cipher attempts (common shifts)
            for shift in [1, 3, 7, 11, 25]:
                caesar_result = ''.join([chr((ord(c) - ord('a') + shift) % 26 + ord('a')) if c.islower()
                                         else chr((ord(c) - ord('A') + shift) % 26 + ord('A')) if c.isupper()
                else c for c in target_data])
                results.append(f"Caesar +{shift}: {caesar_result[:30]}...")

        # Check for encrypted files
        results.append(f"\n=== Encrypted File Detection ===")
        encrypted_files = run_command(
            "find / -name '*.gpg' -o -name '*.asc' -o -name '*.p12' -o -name '*.pfx' 2>/dev/null | head -5", ctf=ctf)
        if encrypted_files.strip():
            results.append(f"🔒 Encrypted files found:\n{encrypted_files}")

    except Exception as e:
        results.append(f"Error analyzing ciphers: {str(e)}")

    return "\n".join(results)


def analyze_certificates(ctf=None, **kwargs) -> str:
    """Analyze SSL/TLS certificates and PKI infrastructure"""
    results = []

    try:
        results.append("Analyzing certificates and PKI infrastructure...")

        # Find certificate files
        cert_files = run_command(
            "find / -name '*.crt' -o -name '*.pem' -o -name '*.cer' -o -name '*.p12' -o -name '*.pfx' 2>/dev/null | head -10",
            ctf=ctf)
        if cert_files.strip():
            results.append("🔐 Certificate files found:")
            for cert_file in cert_files.strip().split('\n'):
                if cert_file.strip():
                    results.append(f"  - {cert_file}")

                    # Try to read certificate details
                    cert_info = run_command(f"openssl x509 -in {cert_file} -text -noout 2>/dev/null | head -20",
                                            ctf=ctf)
                    if cert_info.strip():
                        results.append(f"    Certificate info: {cert_info[:100]}...")

        # Check for private keys
        key_files = run_command(
            "find / -name '*.key' -o -name '*_rsa' -o -name 'id_*' 2>/dev/null | grep -v '.ssh' | head -5", ctf=ctf)
        if key_files.strip():
            results.append(f"\n🔑 Private key files found:\n{key_files}")

        # SSL/TLS vulnerability assessment
        results.append(f"\n=== SSL/TLS Vulnerability Assessment ===")

        # Check for weak SSL configurations
        ssl_configs = [
            '/etc/ssl/openssl.cnf',
            '/etc/nginx/nginx.conf',
            '/etc/apache2/apache2.conf',
            '/etc/httpd/conf/httpd.conf'
        ]

        for config in ssl_configs:
            ssl_config = run_command(f"grep -i 'ssl\\|tls\\|cipher' {config} 2>/dev/null", ctf=ctf)
            if ssl_config.strip():
                results.append(f"SSL config in {config}:")
                results.append(ssl_config[:200])

                # Check for weak ciphers
                weak_ciphers = ['RC4', 'DES', '3DES', 'MD5', 'SHA1']
                for weak_cipher in weak_ciphers:
                    if weak_cipher.lower() in ssl_config.lower():
                        results.append(f"🔥 WEAK CIPHER DETECTED: {weak_cipher}")

        # Certificate transparency and public key analysis
        results.append(f"\n=== Certificate Analysis ===")

        # Check for self-signed certificates
        self_signed = run_command(
            "find /etc/ssl -name '*.crt' -exec openssl x509 -in {} -text -noout \\; 2>/dev/null | grep -i 'issuer.*subject' | head -3",
            ctf=ctf)
        if self_signed.strip():
            results.append("⚠️ Potential self-signed certificates detected")

        # RSA key length analysis
        rsa_keys = run_command(
            "find / -name '*.key' -exec openssl rsa -in {} -text -noout \\; 2>/dev/null | grep -i 'private-key' | head -5",
            ctf=ctf)
        if rsa_keys.strip():
            results.append(f"RSA key analysis:\n{rsa_keys}")

            # Check for weak key lengths
            if '1024 bit' in rsa_keys:
                results.append("🔥 WEAK RSA KEY: 1024-bit keys detected!")

    except Exception as e:
        results.append(f"Error analyzing certificates: {str(e)}")

    return "\n".join(results)


def detect_crypto_weaknesses(target_data: str = None, ctf=None, **kwargs) -> str:
    """Detect cryptographic weaknesses and vulnerabilities"""
    results = []

    try:
        results.append("Detecting cryptographic weaknesses...")

        # Common cryptographic weaknesses
        crypto_weaknesses = {
            'Weak Hash Algorithms': ['MD5', 'SHA1', 'CRC32'],
            'Weak Ciphers': ['DES', '3DES', 'RC4', 'RC2'],
            'Weak Key Lengths': ['512-bit RSA', '1024-bit RSA'],
            'Poor Random Generation': ['Linear congruential', '/dev/urandom misuse'],
            'ECB Mode Usage': ['AES-ECB', 'DES-ECB'],
            'Hardcoded Keys': ['Static IV', 'Default passwords']
        }

        results.append("=== Cryptographic Weakness Categories ===")
        for category, examples in crypto_weaknesses.items():
            results.append(f"\n{category}:")
            for example in examples:
                results.append(f"  - {example}")

        # Search for cryptographic implementations
        results.append(f"\n=== Cryptographic Implementation Analysis ===")

        # Search for crypto libraries
        crypto_libs = run_command("ldd /usr/bin/* 2>/dev/null | grep -i 'ssl\\|crypto\\|gcrypt' | head -5", ctf=ctf)
        if crypto_libs.strip():
            results.append(f"Cryptographic libraries in use:\n{crypto_libs}")

        # Check OpenSSL version
        openssl_version = run_command("openssl version", ctf=ctf)
        if openssl_version.strip():
            results.append(f"OpenSSL version: {openssl_version}")

            # Check for vulnerable OpenSSL versions
            vulnerable_versions = ['1.0.1', '1.0.2a', '1.0.2b', '1.0.2c']
            for vuln_version in vulnerable_versions:
                if vuln_version in openssl_version:
                    results.append(f"🚨 VULNERABLE OPENSSL VERSION: {vuln_version}")

        # Search for hardcoded crypto material
        results.append(f"\n=== Hardcoded Cryptographic Material ===")

        # Search for potential keys in files
        key_patterns = [
            'BEGIN PRIVATE KEY',
            'BEGIN RSA PRIVATE KEY',
            'BEGIN CERTIFICATE',
            'api_key',
            'secret_key',
            'private_key'
        ]

        for pattern in key_patterns:
            key_search = run_command(f"grep -r '{pattern}' /etc /opt /var/www 2>/dev/null | head -3", ctf=ctf)
            if key_search.strip():
                results.append(f"🔑 Found '{pattern}':\n{key_search}")

        # Entropy analysis
        if target_data:
            results.append(f"\n=== Entropy Analysis ===")

            # Calculate character entropy
            char_counts = {}
            for char in target_data:
                char_counts[char] = char_counts.get(char, 0) + 1

            total_chars = len(target_data)
            entropy = 0
            for count in char_counts.values():
                probability = count / total_chars
                if probability > 0:
                    entropy -= probability * (probability.bit_length() - 1)

            results.append(f"Character entropy: {entropy:.2f}")
            if entropy < 3.0:
                results.append("⚠️ Low entropy detected - possible weak encryption")
            elif entropy > 7.0:
                results.append("✓ High entropy - likely strong encryption or compression")

        # Common crypto attack vectors
        results.append(f"\n=== Common Crypto Attack Vectors ===")
        attack_vectors = [
            "Dictionary attacks on weak passwords",
            "Rainbow table attacks on unsalted hashes",
            "Timing attacks on cryptographic operations",
            "Side-channel attacks on key material",
            "Chosen plaintext attacks on weak ciphers",
            "Birthday attacks on short hash functions",
            "Padding oracle attacks on CBC mode",
            "Key reuse attacks on stream ciphers"
        ]

        for vector in attack_vectors:
            results.append(f"  - {vector}")

    except Exception as e:
        results.append(f"Error detecting crypto weaknesses: {str(e)}")

    return "\n".join(results)


def assess_hash_cracking_opportunities(ctf=None, **kwargs) -> str:
    """Assess hash cracking opportunities and provide attack guidance"""
    results = []

    try:
        results.append("Assessing hash cracking opportunities...")

        # Check for available cracking tools
        cracking_tools = {
            'hashcat': 'GPU-accelerated hash cracking',
            'john': 'John the Ripper password cracker',
            'hydra': 'Network service brute forcer',
            'medusa': 'Parallel brute force tool',
            'ncrack': 'Network authentication cracker'
        }

        results.append("=== Available Cracking Tools ===")
        available_tools = []
        for tool, description in cracking_tools.items():
            tool_check = run_command(f"which {tool}", ctf=ctf)
            if tool_check.strip():
                available_tools.append(tool)
                results.append(f"✓ {tool}: {description}")
            else:
                results.append(f"✗ {tool}: Not installed")

        # Wordlist assessment
        results.append(f"\n=== Wordlist Analysis ===")
        common_wordlists = [
            '/usr/share/wordlists/rockyou.txt',
            '/usr/share/wordlists/fasttrack.txt',
            '/usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-1000000.txt',
            '/opt/seclists/Passwords/darkweb2017-top10000.txt'
        ]

        available_wordlists = []
        for wordlist in common_wordlists:
            wordlist_check = run_command(f"ls -la {wordlist} 2>/dev/null", ctf=ctf)
            if wordlist_check.strip():
                available_wordlists.append(wordlist)
                # Get wordlist size
                size_info = run_command(f"wc -l {wordlist} 2>/dev/null", ctf=ctf)
                results.append(f"✓ {wordlist}: {size_info.strip()}")

        if not available_wordlists:
            results.append("⚠️ No common wordlists found - consider installing SecLists")

        # Hash cracking strategies
        results.append(f"\n=== Hash Cracking Strategies ===")

        cracking_strategies = {
            'Dictionary Attack': 'Use common password lists',
            'Brute Force': 'Try all possible combinations',
            'Hybrid Attack': 'Dictionary + rules/mutations',
            'Mask Attack': 'Pattern-based cracking',
            'Combinator Attack': 'Combine multiple wordlists',
            'Rule-based Attack': 'Apply transformation rules'
        }

        for strategy, description in cracking_strategies.items():
            results.append(f"- {strategy}: {description}")

        # Hashcat mode reference
        results.append(f"\n=== Hashcat Hash Modes ===")
        hashcat_modes = {
            '0': 'MD5',
            '100': 'SHA1',
            '1400': 'SHA256',
            '1700': 'SHA512',
            '1000': 'NTLM',
            '3200': 'bcrypt',
            '1800': 'sha512crypt',
            '500': 'md5crypt',
            '300': 'MySQL4.1/MySQL5'
        }

        for mode, hash_type in hashcat_modes.items():
            results.append(f"  {mode}: {hash_type}")

        # Performance optimization tips
        results.append(f"\n=== Performance Optimization ===")
        optimization_tips = [
            "Use GPU acceleration when available (hashcat)",
            "Optimize wordlist order (most common first)",
            "Use rules to generate variations efficiently",
            "Consider distributed cracking for large jobs",
            "Monitor temperature and power consumption",
            "Use appropriate workload tuning (-w parameter)"
        ]

        for tip in optimization_tips:
            results.append(f"  - {tip}")

        # Generate sample commands
        if available_tools:
            results.append(f"\n=== Sample Cracking Commands ===")

            if 'hashcat' in available_tools:
                results.append("Hashcat examples:")
                results.append("  # MD5 dictionary attack")
                results.append("  hashcat -m 0 -a 0 hashes.txt wordlist.txt")
                results.append("  # NTLM with rules")
                results.append("  hashcat -m 1000 -a 0 -r best64.rule hashes.txt wordlist.txt")
                results.append("  # Brute force 8-char passwords")
                results.append("  hashcat -m 0 -a 3 hashes.txt ?a?a?a?a?a?a?a?a")

            if 'john' in available_tools:
                results.append("\nJohn the Ripper examples:")
                results.append("  # Crack with wordlist")
                results.append("  john --wordlist=wordlist.txt hashes.txt")
                results.append("  # Crack with rules")
                results.append("  john --rules --wordlist=wordlist.txt hashes.txt")
                results.append("  # Show cracked passwords")
                results.append("  john --show hashes.txt")

    except Exception as e:
        results.append(f"Error assessing hash cracking: {str(e)}")

    return "\n".join(results)


def crack_hash_dictionary(hash_value: str, hash_type: str = "md5", wordlist: str = None, ctf=None, **kwargs) -> str:
    """Perform dictionary attack on hash"""
    results = []

    try:
        results.append(f"Attempting dictionary attack on {hash_type.upper()} hash...")
        results.append(f"Hash: {hash_value}")

        if not wordlist:
            # Try to find a default wordlist
            default_wordlists = [
                '/usr/share/wordlists/rockyou.txt',
                '/usr/share/wordlists/fasttrack.txt'
            ]

            for wl in default_wordlists:
                if run_command(f"test -f {wl} && echo 'exists'", ctf=ctf).strip() == 'exists':
                    wordlist = wl
                    break

        if not wordlist:
            results.append("⚠️ No wordlist specified and none found")
            return "\n".join(results)

        results.append(f"Using wordlist: {wordlist}")

        # Determine hashcat mode
        hashcat_modes = {
            'md5': '0',
            'sha1': '100',
            'sha256': '1400',
            'sha512': '1700',
            'ntlm': '1000'
        }

        mode = hashcat_modes.get(hash_type.lower(), '0')

        # Check if hashcat is available
        hashcat_check = run_command("which hashcat", ctf=ctf)
        if hashcat_check.strip():
            # Use hashcat
            results.append("Using hashcat for cracking...")

            # Create temporary hash file
            hash_file = f"/tmp/hash_{int(time.time())}.txt"
            run_command(f"echo '{hash_value}' > {hash_file}", ctf=ctf)

            # Run hashcat
            hashcat_cmd = f"hashcat -m {mode} -a 0 {hash_file} {wordlist} --quiet --potfile-disable"
            crack_result = run_command(f"timeout 60 {hashcat_cmd}", ctf=ctf)

            if crack_result.strip():
                results.append(f"✓ Hashcat result:\n{crack_result}")
            else:
                results.append("Hashcat completed - check if password was found")

            # Clean up
            run_command(f"rm -f {hash_file}", ctf=ctf)

        # Try John the Ripper if available
        john_check = run_command("which john", ctf=ctf)
        if john_check.strip():
            results.append("\nTrying John the Ripper...")

            # Create John format
            if hash_type.lower() == 'md5':
                john_hash = f"user:{hash_value}::::::::"
            else:
                john_hash = hash_value

            hash_file = f"/tmp/john_hash_{int(time.time())}.txt"
            run_command(f"echo '{john_hash}' > {hash_file}", ctf=ctf)

            # Run John
            john_cmd = f"john --wordlist={wordlist} {hash_file}"
            john_result = run_command(f"timeout 60 {john_cmd}", ctf=ctf)

            if john_result.strip():
                results.append(f"John result:\n{john_result}")

            # Show results
            john_show = run_command(f"john --show {hash_file}", ctf=ctf)
            if john_show.strip():
                results.append(f"✓ Cracked password:\n{john_show}")

            # Clean up
            run_command(f"rm -f {hash_file}", ctf=ctf)

        # Manual dictionary attack for simple cases
        if hash_type.lower() == 'md5':
            results.append("\nAttempting manual MD5 cracking (first 100 words)...")
            wordlist_sample = run_command(f"head -100 {wordlist}", ctf=ctf)

            target_hash = hash_value.lower()
            for word in wordlist_sample.split('\n')[:20]:  # First 20 words
                if word.strip():
                    word_hash = hashlib.md5(word.strip().encode()).hexdigest()
                    if word_hash == target_hash:
                        results.append(f"🔥 PASSWORD FOUND: {word.strip()}")
                        break

    except Exception as e:
        results.append(f"Error cracking hash: {str(e)}")

    return "\n".join(results)


def generate_crypto_wordlist(base_words: List[str] = None, ctf=None, **kwargs) -> str:
    """Generate custom wordlist for crypto attacks"""
    results = []

    try:
        results.append("Generating custom cryptographic wordlist...")

        if not base_words:
            base_words = [
                'password', 'admin', 'root', 'user', 'test',
                'secret', 'key', 'private', 'public', 'crypto'
            ]

        results.append(f"Base words: {', '.join(base_words)}")

        # Generate variations
        wordlist = set(base_words)

        # Add common mutations
        for word in base_words:
            # Capitalization variations
            wordlist.add(word.capitalize())
            wordlist.add(word.upper())

            # Number additions
            for num in ['1', '123', '2024', '01', '00']:
                wordlist.add(word + num)
                wordlist.add(num + word)

            # Special character additions
            for char in ['!', '@', '#', '$', '*']:
                wordlist.add(word + char)
                wordlist.add(char + word)

            # Common substitutions
            mutations = {
                'a': '@', 'o': '0', 'i': '1', 'e': '3', 's': '$', 't': '7'
            }
            mutated_word = word
            for old_char, new_char in mutations.items():
                mutated_word = mutated_word.replace(old_char, new_char)
            wordlist.add(mutated_word)

        # Add common crypto-related terms
        crypto_terms = [
            'aes', 'rsa', 'des', 'sha', 'md5', 'ssl', 'tls',
            'cipher', 'encrypt', 'decrypt', 'hash', 'hmac',
            'certificate', 'keystore', 'truststore'
        ]
        wordlist.update(crypto_terms)

        # Save wordlist
        wordlist_file = f"/tmp/crypto_wordlist_{int(time.time())}.txt"
        wordlist_content = '\n'.join(sorted(wordlist))

        write_result = run_command(f"echo '{wordlist_content}' > {wordlist_file}", ctf=ctf)

        results.append(f"✓ Generated wordlist with {len(wordlist)} entries")
        results.append(f"Saved to: {wordlist_file}")

        # Show sample entries
        sample = run_command(f"head -10 {wordlist_file}", ctf=ctf)
        results.append(f"\nSample entries:\n{sample}")

        return "\n".join(results)

    except Exception as e:
        results.append(f"Error generating wordlist: {str(e)}")
        return "\n".join(results)


def analyze_random_data(data: str, ctf=None, **kwargs) -> str:
    """Analyze data for randomness and cryptographic quality"""
    results = []

    try:
        results.append("Analyzing data randomness and cryptographic quality...")
        results.append(f"Data length: {len(data)} characters")

        if len(data) < 10:
            results.append("⚠️ Data too short for meaningful analysis")
            return "\n".join(results)

        # Character frequency analysis
        char_freq = {}
        for char in data:
            char_freq[char] = char_freq.get(char, 0) + 1

        unique_chars = len(char_freq)
        results.append(f"Unique characters: {unique_chars}")

        # Calculate entropy
        total_chars = len(data)
        entropy = 0
        for count in char_freq.values():
            probability = count / total_chars
            if probability > 0:
                entropy -= probability * (probability.bit_length() - 1)

        results.append(f"Shannon entropy: {entropy:.3f}")

        # Entropy quality assessment
        if entropy < 2.0:
            results.append("🔴 Very low entropy - likely not random")
        elif entropy < 4.0:
            results.append("🟡 Low entropy - possibly weak randomness")
        elif entropy < 6.0:
            results.append("🟢 Moderate entropy - decent randomness")
        else:
            results.append("🟢 High entropy - good randomness")

        # Pattern analysis
        results.append(f"\n=== Pattern Analysis ===")

        # Check for repeated patterns
        pattern_lengths = [2, 3, 4, 5]
        for length in pattern_lengths:
            patterns = {}
            for i in range(len(data) - length + 1):
                pattern = data[i:i + length]
                patterns[pattern] = patterns.get(pattern, 0) + 1

            repeated_patterns = {p: c for p, c in patterns.items() if c > 1}
            if repeated_patterns:
                most_common = max(repeated_patterns.items(), key=lambda x: x[1])
                results.append(f"Repeated {length}-char pattern: '{most_common[0]}' appears {most_common[1]} times")

        # Check for sequential characters
        sequential_count = 0
        for i in range(len(data) - 1):
            if ord(data[i + 1]) == ord(data[i]) + 1:
                sequential_count += 1

        sequential_ratio = sequential_count / (len(data) - 1) if len(data) > 1 else 0
        results.append(f"Sequential character ratio: {sequential_ratio:.3f}")

        if sequential_ratio > 0.1:
            results.append("⚠️ High sequential character ratio - may not be random")

        # Chi-square test (simplified)
        if len(set(data)) > 1:
            expected_freq = len(data) / len(set(data))
            chi_square = sum((count - expected_freq) ** 2 / expected_freq for count in char_freq.values())
            results.append(f"Chi-square statistic: {chi_square:.3f}")

        # Cryptographic recommendations
        results.append(f"\n=== Cryptographic Assessment ===")

        if entropy > 6.0 and sequential_ratio < 0.05:
            results.append("✓ Data appears cryptographically strong")
        elif entropy > 4.0:
            results.append("⚠️ Data has moderate cryptographic strength")
        else:
            results.append("🔴 Data appears cryptographically weak")
            results.append("Recommendations:")
            results.append("  - Use cryptographically secure random number generator")
            results.append("  - Increase entropy source diversity")
            results.append("  - Consider key stretching techniques")

    except Exception as e:
        results.append(f"Error analyzing random data: {str(e)}")

    return "\n".join(results)
