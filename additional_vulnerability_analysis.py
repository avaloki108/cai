#!/usr/bin/env python3

print("""
## ADDITIONAL CRITICAL VULNERABILITY: ENABLECURRENTSKIMCANDIDATEASCOLLATERAL

### Vulnerability Location
File: core-contracts/src/ERC721WrapperBase.sol
Function: enableCurrentSkimCandidateAsCollateral()
Lines: 320-323

### Vulnerability Description
The `enableCurrentSkimCandidateAsCollateral()` function has the same integer underflow vulnerability as the `skim()` function, and it's also permissionless.

```solidity
function enableCurrentSkimCandidateAsCollateral() external returns (bool) {
    uint256 tokenId = getTokenIdToSkim();  // <-- Same vulnerable call
    return enableTokenIdAsCollateral(tokenId);
}
```

### Root Cause
Same as the `skim()` vulnerability:
1. When the contract owns 0 NFTs, `getTokenIdToSkim()` will cause an underflow
2. The function then tries to enable a token ID that doesn't exist or is invalid
3. This could lead to enabling arbitrary token IDs as collateral

### Attack Scenario
1. Attacker waits for contract to have 0 NFTs
2. Calls `enableCurrentSkimCandidateAsCollateral()`
3. Due to underflow, an arbitrary token ID gets enabled as collateral
4. Attacker could potentially manipulate the contract's collateral tracking

### Impact
- **Severity**: CRITICAL (9.5/10)
- **Permissionless**: YES - Any attacker can call this function
- **Potential Damage**:
  - Incorrect collateral accounting
  - Manipulation of contract state
  - Potential for theft if combined with other operations

### Recommendation
Add the same underflow protection:

```solidity
function enableCurrentSkimCandidateAsCollateral() external returns (bool) {
    uint256 totalTokensOwnedByThis = IERC721Enumerable(address(underlying)).balanceOf(address(this));
    require(totalTokensOwnedByThis > 0, "No tokens available");
    
    uint256 tokenId = getTokenIdToSkim();
    return enableTokenIdAsCollateral(tokenId);
}
```

## SUMMARY OF CRITICAL FINDINGS

### 1. Integer Underflow in skim() function
- **Severity**: CRITICAL (9.8/10)
- **Permissionless**: YES
- **Location**: ERC721WrapperBase.sol, lines 307-317
- **Impact**: State corruption, potential theft, DoS

### 2. Integer Underflow in enableCurrentSkimCandidateAsCollateral() function
- **Severity**: CRITICAL (9.5/10)  
- **Permissionless**: YES
- **Location**: ERC721WrapperBase.sol, lines 320-323
- **Impact**: Incorrect collateral accounting, state manipulation

### Root Cause Analysis
Both vulnerabilities stem from the same core issue in `getTokenIdToSkim()`:
```solidity
function getTokenIdToSkim() public view override returns (uint256) {
    uint256 totalTokensOwnedByThis = IERC721Enumerable(address(underlying)).balanceOf(address(this));
    return IERC721Enumerable(address(underlying)).tokenOfOwnerByIndex(address(this), totalTokensOwnedByThis - 1);  // <-- UNDERFLOW HERE
}
```

### Fix Recommendation
The `getTokenIdToSkim()` function should be fixed to prevent underflow:

```solidity
function getTokenIdToSkim() public view override returns (uint256) {
    uint256 totalTokensOwnedByThis = IERC721Enumerable(address(underlying)).balanceOf(address(this));
    require(totalTokensOwnedByThis > 0, "No tokens available");
    return IERC721Enumerable(address(underlying)).tokenOfOwnerByIndex(address(this), totalTokensOwnedByThis - 1);
}
```

This would protect both `skim()` and `enableCurrentSkimCandidateAsCollateral()` functions from the underflow vulnerability.
""")
