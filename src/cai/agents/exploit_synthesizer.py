"""
Exploit Synthesis Agent

Given a confirmed suspicious pattern, attempt to synthesize a working exploit.
Uses Foundry to write and run actual PoCs.

Non-negotiable rule:
Every high-severity finding must have exploit synthesis attempted.

Integration:
- Reads hypothesis from reasoning.register_hypothesis
- Uses fork_test.generate_fork_test for PoC template
- Runs forge test to verify exploit
- Outputs working exploit code OR documented failure with blocking condition

Output:
- Working exploit code with full test file
- OR detailed failure analysis explaining why exploit doesn't work
"""

import json
import os
from typing import Any, Dict, List, Optional
from cai.sdk.agents import function_tool


# Exploit synthesis patterns
EXPLOIT_PATTERNS = {
    "reentrancy": {
        "setup": "// Attacker state\naddress attacker;\nuint256 initialBalance = 1000 ether;",
        "exploit_steps": [
            "call vulnerableContract.vulnerableFunction();",
            "attacker.withdraw(exploitVictimAmount);",
        ],
        "test_assertion": "assert(initialBalance + amount) == attacker.balance);",
    },
    "oracle_manipulation": {
        "setup": "// Setup\nIERC20 oracle = IERC20(address(oracleAddress));\naddress attacker;",
        "exploit_steps": [
            "IERC20 token = IERC20(address(tokenAddress));\ntoken.mint(address(attacker, amountToMint));",
            "// Step 2: Manipulate oracle price\n// Use flash loan to buy token and sell for manipulated price",
            "// For TWAP oracles, sandwich attack instead",
        ],
        "test_assertion": "assert(priceAfterManipulation > originalPrice);",
    },
    "access_control_bypass": {
        "setup": "// Find admin or critical function with weak access control",
        "exploit_steps": [
            "// Call function directly or bypass modifier",
            "// If using delegatecall, set storage to attacker-controlled value",
        ],
        "test_assertion": "assert(successfullyCalled || attackerGainedControl);",
    },
}


def _generate_exploit_code(
    hypothesis: str, contract_name: str, pattern_key: str
) -> str:
    """
    Generate Foundry test code from exploit pattern.

    Args:
        hypothesis: Attack hypothesis describing vulnerability
        contract_name: Name of contract being tested
        pattern_key: Key from EXPLOIT_PATTERNS

    Returns:
        Generated Solidity test code
    """
    pattern = EXPLOIT_PATTERNS.get(pattern_key.lower())

    if not pattern:
        return f"Error: Unknown exploit pattern {pattern_key}"

    setup = pattern.get("setup", "")
    exploit_steps = "\n".join(pattern.get("exploit_steps", []))
    test_assertion = pattern.get("test_assertion", "")

    # Build test contract
    test_code = f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface ITarget {{
    function vulnerableFunction() external;
}}

contract Exploit_{contract_name} is Test {{
    address public constant VICTIM_CONTRACT = 0x{{
        '0'*40
    }};
    address public constant EXPLOIT_CONTRACT = 0x{{
        '0'*40
    }};
    address public constant ATTACKER = 0x{{
        '0'*40
    }};
    
    ITarget vulnerableContract;
    
    function setUp() public {{
        vm.deal(ATTACKER, 1000 ether);
        vulnerableContract = ITarget(EXPLOIT_CONTRACT);
    }}
    
    function test_exploit() public {{
        // Exploit steps from hypothesis
{exploit_steps}
        
        // Assertion from pattern
{test_assertion}
        
        vm.stopPrank();
    }}
}}"""

    return test_code


def _analyze_exploit_failure(
    hypothesis: str, error_output: str, pattern_key: str
) -> str:
    """
    Analyze why exploit attempt failed.

    Args:
        hypothesis: Original attack hypothesis
        error_output: Forge test error output
        pattern_key: Type of exploit attempted

    Returns:
        Failure analysis with blocking condition
    """
    analysis = {
        "hypothesis": hypothesis,
        "pattern_type": pattern_key,
        "exploit_failed": True,
        "blocking_condition": "",
        "alternative_approaches": [],
    }

    # Parse error output for specific failure modes
    error_lower = error_output.lower()

    # Mode specific analyses
    if "revert" in error_lower:
        analysis["blocking_condition"] = (
            "Transaction reverted - exploit prevented by check/revert/assert"
        )
        analysis["alternative_approaches"].append(
            "Bypass the check/revert causing failure"
        )

    elif "assertion failed" in error_lower:
        analysis["blocking_condition"] = (
            "Test assertion failed - exploit doesn't cause expected outcome"
        )
        analysis["alternative_approaches"].append(
            "Review hypothesis - may require different approach"
        )

    elif "out of gas" in error_lower:
        analysis["blocking_condition"] = (
            "Gas exhaustion - exploit requires too much gas to be viable"
        )
        analysis["alternative_approaches"].append("Optimize exploit to reduce gas cost")

    elif "contract not found" in error_lower:
        analysis["blocking_condition"] = "Contract not deployed or wrong address"
        analysis["alternative_approaches"].append(
            "Verify contract address and deployment"
        )

    else:
        analysis["blocking_condition"] = "Unknown error - requires manual analysis"
        analysis["alternative_approaches"].append(
            "Review forge error output and test logic"
        )

    return json.dumps(analysis, indent=2)


@function_tool
def synthesize_exploit(
    hypothesis_index: int, contract_path: str, pattern_key: str, ctf=None
) -> str:
    """
    Attempt to synthesize a working exploit from a hypothesis.

    Args:
        hypothesis_index: Index of hypothesis to test (from reasoning.register_hypothesis)
        contract_path: Path to Solidity contract file
        pattern_key: Type of exploit to synthesize (reentrancy, oracle_manipulation, access_control_bypass)

    Returns:
        JSON with synthesis results
    """
    try:
        # In real implementation, would read hypothesis from reasoning module
        hypothesis = f"Hypothesis {hypothesis_index}: Testing exploit via {pattern_key}"

        # Get contract name from path
        contract_name = os.path.basename(contract_path).replace(".sol", "")

        # Generate exploit code
        test_code = _generate_exploit_code(hypothesis, contract_name, pattern_key)

        # Save test file
        test_file = f"test_{pattern_key}_{contract_name}.t.sol"
        test_path = os.path.join("test/", test_file)

        with open(test_path, "w", encoding="utf-8") as f:
            f.write(test_code)

        # Prepare forge command
        forge_command = f"forge test --match-path test/ --match-contract Exploit_{contract_name} -vv"

        return json.dumps(
            {
                "status": "test_generated",
                "hypothesis_index": hypothesis_index,
                "pattern_key": pattern_key,
                "contract_name": contract_name,
                "test_file": test_file,
                "test_path": test_path,
                "forge_command": forge_command,
                "next_step": f"Run: {{forge_command}}",
            },
            indent=2,
        )

    except Exception as e:
        return json.dumps({"error": f"Error synthesizing exploit: {str(e)}"})


@function_tool
def run_exploit_test(test_file: str, pattern_key: str, ctf=None) -> str:
    """
    Run synthesized exploit test with Foundry.

    Executes the test file generated by synthesize_exploit.
    Captures output and analyzes for success/failure.

    Args:
        test_file: Path to .t.sol test file
        pattern_key: Type of exploit being tested

    Returns:
        JSON with test execution results
    """
    try:
        # Prepare forge test command
        forge_command = f"forge test --match-path test/ -vv"

        # Execute test
        exit_code = os.system(forge_command + " 2>&1")
        success = exit_code == 0

        # Read test output
        output = ""
        if success:
            # In real implementation, would read from foundry.out or capture stderr
            # For now, simulate with placeholder
            if exit_code == 0:
                output = "Test passed - exploit succeeded"
                analysis = {
                    "exploit_succeeded": True,
                    "test_passed": True,
                }
            else:
                output = f"Test failed with exit code {exit_code}"
                analysis = _analyze_exploit_failure(
                    f"Testing exploit via {pattern_key}",
                    output,
                    pattern_key,
                )

        return json.dumps(
            {
                "status": "completed" if success else "failed",
                "exit_code": exit_code,
                "output": output,
                "forge_command": forge_command,
                "analysis": analysis.get("analysis", {}),
            },
            indent=2,
        )

    except Exception as e:
        return json.dumps({"error": f"Error running exploit test: {str(e)}"})


@function_tool
def verify_exploitability(findings: str, high_severity_count: int = 1, ctf=None) -> str:
    """
    Verify that all high-severity findings have exploit synthesis attempted.

    Non-negotiable rule from plan:
    Every high-severity finding must have exploit synthesis attempted.

    Args:
        findings: JSON string of audit findings
        high_severity_count: Expected number of high-severity findings
        ctf: CTF flag for testing

    Returns:
        JSON with verification status
    """
    try:
        findings_data = json.loads(findings) if isinstance(findings, str) else findings

        high_severity_verified = []
        high_severity_missing = []

        # Count high-severity findings
        if isinstance(findings_data, dict):
            finding = findings_data.get("finding", {})
        severity = finding.get("severity", "").lower()
        if severity == "high" or severity == "critical":
            synthesis_attempted = finding.get("exploit_synthesis_attempted", False)
            high_severity_verified.append(
                {
                    "finding": finding,
                    "synthesis_attempted": synthesis_attempted,
                }
            )
            if not synthesis_attempted:
                high_severity_missing.append(finding)
        else:
            for finding in findings_data:
                severity = finding.get("severity", "").lower()
                if severity == "high" or severity == "critical":
                    synthesis_attempted = finding.get(
                        "exploit_synthesis_attempted", False
                    )
                    if not synthesis_attempted:
                        high_severity_missing.append(finding)

        return json.dumps(
            {
                "status": "verification_complete",
                "high_severity_count": len(high_severity_verified)
                + len(high_severity_missing),
                "high_severity_verified_count": len(high_severity_verified),
                "high_severity_missing_count": len(high_severity_missing),
                "high_severity_missing_findings": high_severity_missing[:10],
                "compliance": "All high-severity findings have synthesis attempts"
                if len(high_severity_missing) == 0
                else f"Missing: {len(high_severity_missing)} high-severity findings require synthesis",
            },
            indent=2,
        )

    except Exception as e:
        return json.dumps({"error": f"Error verifying exploitability: {str(e)}"})
