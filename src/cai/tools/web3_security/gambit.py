"""
Gambit - Solidity Mutation Testing Tool

Gambit performs mutation testing on Solidity smart contracts to evaluate
test suite quality by introducing small changes (mutants) to the code
and checking if tests catch them.

Note: The old function names (gambit_analyze, gambit_verify_property, gambit_explore_paths)
are maintained as aliases for backward compatibility.
"""

from typing import Optional, List
from cai.tools.common import run_command
from cai.sdk.agents import function_tool
from .config import GAMBIT_PATH


@function_tool
def gambit_mutate(
    target: str,
    output_dir: Optional[str] = None,
    solc_version: Optional[str] = None,
    mutations: Optional[str] = None,
    functions: Optional[str] = None,
    contracts: Optional[str] = None,
    num_mutants: Optional[int] = None,
    seed: Optional[int] = None,
    skip_validate: bool = False,
    extra_args: str = "",
    ctf=None
) -> str:
    """
    Generate mutants from Solidity source code.

    Mutation testing helps evaluate test suite effectiveness by creating
    slightly modified versions of your code (mutants) that should be caught
    by good tests.

    Args:
        target: Path to Solidity file or directory to mutate
        output_dir: Output directory for mutants (default: gambit_out)
        solc_version: Solidity compiler version to use
        mutations: Comma-separated list of mutation operators to apply
                  Available operators:
                  - BinaryOpMutation: Change binary operators (+, -, *, /, etc.)
                  - UnaryOpMutation: Change unary operators (!, ~, ++, --)
                  - RequireMutation: Modify require conditions
                  - AssignmentMutation: Change assignment operators
                  - DeleteExpressionMutation: Remove expressions
                  - IfStatementMutation: Modify if conditions
                  - SwapArgumentsMutation: Swap function arguments
                  - ElimDelegateMutation: Remove delegate calls
        functions: Comma-separated list of function names to mutate
        contracts: Comma-separated list of contract names to mutate
        num_mutants: Maximum number of mutants to generate
        seed: Random seed for reproducible mutation generation
        skip_validate: Skip validation that mutants compile
        extra_args: Additional Gambit arguments

    Returns:
        str: Mutation generation results including mutant IDs and locations

    Example:
        gambit_mutate("Token.sol", num_mutants=50, mutations="BinaryOpMutation,RequireMutation")
    """
    args = ["mutate"]

    if output_dir:
        args.append(f"--outdir {output_dir}")

    if solc_version:
        args.append(f"--solc-version {solc_version}")

    if mutations:
        args.append(f"--mutations {mutations}")

    if functions:
        args.append(f"--functions {functions}")

    if contracts:
        args.append(f"--contracts {contracts}")

    if num_mutants:
        args.append(f"--num-mutants {num_mutants}")

    if seed:
        args.append(f"--seed {seed}")

    if skip_validate:
        args.append("--skip-validate")

    if extra_args:
        args.append(extra_args)

    args.append(target)

    command = f"{GAMBIT_PATH} {' '.join(args)}"
    return run_command(command, ctf=ctf)


@function_tool
def gambit_summary(
    gambit_dir: str = "gambit_out",
    mids: Optional[str] = None,
    show_diffs: bool = False,
    extra_args: str = "",
    ctf=None
) -> str:
    """
    Summarize mutants generated by a Gambit run.

    Args:
        gambit_dir: Directory containing Gambit output (default: gambit_out)
        mids: Comma-separated list of mutant IDs to summarize (default: all)
        show_diffs: Show code diffs for each mutant
        extra_args: Additional arguments

    Returns:
        str: Summary of generated mutants with their locations and types

    Example:
        gambit_summary("gambit_out", mids="1,2,3", show_diffs=True)
    """
    args = ["summary", f"--mutation-dir {gambit_dir}"]

    if mids:
        args.append(f"--mids {mids}")

    if show_diffs:
        args.append("--diffs")

    if extra_args:
        args.append(extra_args)

    command = f"{GAMBIT_PATH} {' '.join(args)}"
    return run_command(command, ctf=ctf)


@function_tool
def gambit_run_tests(
    gambit_dir: str = "gambit_out",
    test_command: str = "forge test",
    mids: Optional[str] = None,
    timeout: int = 300,
    parallel: int = 1,
    extra_args: str = "",
    ctf=None
) -> str:
    """
    Run tests against generated mutants to calculate mutation score.

    The mutation score indicates test suite quality:
    - High score (>80%): Tests catch most mutations - good coverage
    - Low score (<50%): Tests miss many mutations - improve tests

    Args:
        gambit_dir: Directory containing Gambit mutants
        test_command: Command to run tests (default: "forge test")
        mids: Comma-separated list of mutant IDs to test (default: all)
        timeout: Timeout per mutant in seconds (default: 300)
        parallel: Number of parallel test runs (default: 1)
        extra_args: Additional arguments

    Returns:
        str: Mutation testing results with kill rate and surviving mutants

    Example:
        gambit_run_tests("gambit_out", test_command="forge test --match-contract TokenTest")
    """
    # This is a helper that runs tests on each mutant
    # Gambit itself doesn't have a built-in test runner, so we orchestrate it
    import os
    import subprocess

    results = []
    results.append(f"Running mutation testing with: {test_command}")
    results.append(f"Mutant directory: {gambit_dir}")
    results.append("=" * 60)

    # Get list of mutants
    summary_cmd = f"{GAMBIT_PATH} summary --mutation-dir {gambit_dir}"
    if mids:
        summary_cmd += f" --mids {mids}"

    summary_result = run_command(summary_cmd, ctf=ctf)
    results.append(f"Mutants to test:\n{summary_result}")

    results.append("\n" + "=" * 60)
    results.append("Run tests manually on each mutant using:")
    results.append(f"  1. Copy mutant file over original")
    results.append(f"  2. Run: {test_command}")
    results.append(f"  3. Record if tests pass (mutant survives) or fail (mutant killed)")
    results.append("=" * 60)

    return "\n".join(results)


@function_tool
def gambit_analyze_survivors(
    gambit_dir: str = "gambit_out",
    survivor_ids: str = "",
    ctf=None
) -> str:
    """
    Analyze surviving mutants to understand test gaps.

    Surviving mutants indicate code paths or edge cases not covered by tests.

    Args:
        gambit_dir: Directory containing Gambit mutants
        survivor_ids: Comma-separated list of surviving mutant IDs

    Returns:
        str: Analysis of surviving mutants with suggestions for test improvements
    """
    results = []
    results.append("SURVIVING MUTANT ANALYSIS")
    results.append("=" * 60)

    if not survivor_ids:
        results.append("No survivor IDs provided. Run gambit_summary first to identify mutants.")
        return "\n".join(results)

    # Get details on survivors
    summary_cmd = f"{GAMBIT_PATH} summary --mutation-dir {gambit_dir} --mids {survivor_ids} --diffs"
    summary_result = run_command(summary_cmd, ctf=ctf)
    results.append(summary_result)

    results.append("\n" + "=" * 60)
    results.append("TEST IMPROVEMENT SUGGESTIONS")
    results.append("=" * 60)
    results.append("""
For each surviving mutant, consider:
1. Does the mutation change observable behavior? If not, it may be equivalent.
2. What input/state would trigger the mutated code path?
3. What assertion would catch the changed behavior?

Common test gaps:
- Boundary conditions (0, max values, empty arrays)
- Error paths (reverts, requires)
- State transitions (before/after)
- Return value checks
""")

    return "\n".join(results)


# =============================================================================
# BACKWARD COMPATIBILITY ALIASES
# =============================================================================
# The old function names are maintained for backward compatibility with
# existing code that imports them. They map to the new mutation testing functions.

@function_tool
def gambit_analyze(target: str, args: str = "", ctf=None) -> str:
    """
    [DEPRECATED] Use gambit_mutate instead.
    
    Run Gambit mutation testing on Solidity smart contracts.
    This is a backward compatibility alias for gambit_mutate.
    """
    return gambit_mutate(target=target, extra_args=args, ctf=ctf)


@function_tool  
def gambit_verify_property(target: str, property_file: str, args: str = "", ctf=None) -> str:
    """
    [DEPRECATED] Gambit is now focused on mutation testing.
    
    This function is maintained for backward compatibility but now runs
    mutation testing instead of property verification.
    Use gambit_mutate for mutation testing or certora_verify for property verification.
    """
    return gambit_mutate(target=target, extra_args=args, ctf=ctf)


@function_tool
def gambit_explore_paths(target: str, max_paths: int = 100, args: str = "", ctf=None) -> str:
    """
    [DEPRECATED] Gambit is now focused on mutation testing.
    
    This function is maintained for backward compatibility but now runs
    mutation testing instead of path exploration.
    Use gambit_mutate for mutation testing or mythril_analyze for path exploration.
    """
    return gambit_mutate(target=target, num_mutants=max_paths, extra_args=args, ctf=ctf)
